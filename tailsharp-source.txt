

===== C:\Users\burba\tailsharp\src\app\api\admin\clear-trades\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';

const redis = new Redis(process.env.KV_REDIS_URL!);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json().catch(() => ({}));
    const confirm = body.confirm;

    if (confirm !== 'DELETE_ALL_TRADES') {
      return NextResponse.json({
        error: 'Safety check failed',
        message: 'Send { "confirm": "DELETE_ALL_TRADES" } to confirm deletion',
      }, { status: 400 });
    }

    const deleted = await redis.del('executed-trades');

    return NextResponse.json({
      success: true,
      message: 'All executed trades have been cleared',
      keysDeleted: deleted,
    });
  } catch (error) {
    console.error('[Admin] Clear trades error:', error);
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}

export async function GET() {
  try {
    const count = await redis.llen('executed-trades');
    return NextResponse.json({
      tradesCount: count,
      message: 'POST with { "confirm": "DELETE_ALL_TRADES" } to clear all trades',
    });
  } catch (error) {
    return NextResponse.json({
      error: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}


===== C:\Users\burba\tailsharp\src\app\api\copy-settings\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';

const redis = new Redis(process.env.KV_REDIS_URL!);
const SETTINGS_KEY = 'copy-settings';

export async function GET() {
  try {
    const data = await redis.get(SETTINGS_KEY);
    const settings = data ? JSON.parse(data) : [];
    return NextResponse.json({ settings });
  } catch (err) {
    console.error('Error fetching copy settings:', err);
    return NextResponse.json(
      { error: 'Failed to fetch copy settings' },
      { status: 500 }
    );
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();

    if (!Array.isArray(body)) {
      return NextResponse.json(
        { error: 'Body must be an array of settings' },
        { status: 400 }
      );
    }

    // Basic validation / normalization
    const cleaned = body.map((s) => ({
      traderId: String(s.traderId),
      isActive: Boolean(s.isActive),
      allocationUsd: Number(s.allocationUsd) || 0,
      maxPositionPercent: Number(s.maxPositionPercent) || 0,
    }));

    await redis.set(SETTINGS_KEY, JSON.stringify(cleaned));
    return NextResponse.json({ ok: true, settings: cleaned });
  } catch (err) {
    console.error('Error updating copy settings:', err);
    return NextResponse.json(
      { error: 'Failed to update copy settings' },
      { status: 500 }
    );
  }
}


===== C:\Users\burba\tailsharp\src\app\api\copy-trades\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';

const redis = new Redis(process.env.KV_REDIS_URL!);

export async function GET(request: NextRequest) {
  try {
    const tradesKey = 'executed-trades';
    const tradesData = await redis.lrange(tradesKey, 0, 99);
    
    const trades = tradesData.map((trade: string) => JSON.parse(trade));

    return NextResponse.json({
      trades,
      count: trades.length
    });
  } catch (error) {
    console.error('Failed to fetch copy trades:', error);
    return NextResponse.json({ error: 'Failed to fetch copy trades' }, { status: 500 });
  }
}


===== C:\Users\burba\tailsharp\src\app\api\executed-trades\route.ts =====

import { NextResponse } from 'next/server';
import Redis from 'ioredis';

const redis = new Redis(process.env.KV_REDIS_URL!);
const TRADES_KEY = 'executed-trades';

export async function GET() {
  try {
    // Get last 50 executed trades (most recent first)
    const items = await redis.lrange(TRADES_KEY, 0, 49);
    const trades = items.map((t) => JSON.parse(t));

    return NextResponse.json({ trades });
  } catch (err) {
    console.error('Error fetching executed trades:', err);
    return NextResponse.json(
      { error: 'Failed to fetch executed trades' },
      { status: 500 }
    );
  }
}


===== C:\Users\burba\tailsharp\src\app\api\preflight\route.ts =====

import { NextResponse } from 'next/server';
import Redis from 'ioredis';
import { KalshiClient } from '@/lib/kalshi/client';
import { IS_SIMULATION_SERVER } from '@/lib/env';

export async function GET() {
  const checks: {
    name: string;
    status: 'pass' | 'fail' | 'warn';
    message: string;
  }[] = [];

  // Check 1: Environment variables
  const hasKalshiKeyId = !!process.env.KALSHI_API_KEY_ID;
  const hasKalshiPrivateKey = !!process.env.KALSHI_PRIVATE_KEY;
  const isDemo = process.env.KALSHI_USE_DEMO === 'true';
  
  checks.push({
    name: 'Kalshi API Key ID',
    status: hasKalshiKeyId ? 'pass' : 'fail',
    message: hasKalshiKeyId ? 'API Key ID is configured' : 'Missing KALSHI_API_KEY_ID',
  });

  checks.push({
    name: 'Kalshi Private Key',
    status: hasKalshiPrivateKey ? 'pass' : 'fail',
    message: hasKalshiPrivateKey ? 'Private key is configured' : 'Missing KALSHI_PRIVATE_KEY',
  });

  checks.push({
    name: 'Kalshi Environment',
    status: isDemo ? 'warn' : 'pass',
    message: isDemo ? 'Using DEMO API (not production)' : 'Using PRODUCTION API',
  });

  checks.push({
    name: 'Simulation Mode',
    status: IS_SIMULATION_SERVER ? 'warn' : 'pass',
    message: IS_SIMULATION_SERVER 
      ? 'Simulation mode ON - trades will NOT execute' 
      : 'Simulation mode OFF - trades WILL execute with real money',
  });

  // Check 2: Redis connection
  let redisOk = false;
  try {
    const redis = new Redis(process.env.KV_REDIS_URL!);
    await redis.ping();
    redisOk = true;
    await redis.quit();
  } catch (e) {
    redisOk = false;
  }

  checks.push({
    name: 'Redis Connection',
    status: redisOk ? 'pass' : 'fail',
    message: redisOk ? 'Redis is connected' : 'Cannot connect to Redis',
  });

  // Check 3: Kalshi API connection and balance
  let kalshiOk = false;
  let balance = 0;
  try {
    const client = new KalshiClient(
      process.env.KALSHI_API_KEY_ID!,
      process.env.KALSHI_PRIVATE_KEY!,
      isDemo
    );
    const balanceData = await client.getBalance();
    balance = balanceData.balance || 0;
    kalshiOk = true;
  } catch (e) {
    kalshiOk = false;
  }

  checks.push({
    name: 'Kalshi API Connection',
    status: kalshiOk ? 'pass' : 'fail',
    message: kalshiOk ? 'Successfully connected to Kalshi' : 'Cannot connect to Kalshi API',
  });

  checks.push({
    name: 'Kalshi Balance',
    status: kalshiOk ? (balance > 0 ? 'pass' : 'warn') : 'fail',
    message: kalshiOk ? 'Balance: $' + (balance / 100).toFixed(2) : 'Could not fetch balance',
  });

  // Check 4: Copy settings
  let settingsCount = 0;
  let activeCount = 0;
  let totalAllocation = 0;
  try {
    const redis = new Redis(process.env.KV_REDIS_URL!);
    const settingsData = await redis.get('copy-settings');
    const settings = settingsData ? JSON.parse(settingsData) : [];
    settingsCount = settings.length;
    activeCount = settings.filter((s: any) => s.isActive).length;
    totalAllocation = settings.reduce((sum: number, s: any) => sum + (s.allocationUsd || 0), 0);
    await redis.quit();
  } catch (e) {
    // ignore
  }

  checks.push({
    name: 'Tracked Traders',
    status: settingsCount > 0 ? 'pass' : 'warn',
    message: settingsCount + ' traders tracked, ' + activeCount + ' active',
  });

  checks.push({
    name: 'Total Allocation',
    status: totalAllocation > 0 ? 'pass' : 'warn',
    message: '$' + totalAllocation.toFixed(2) + ' allocated for copy trading',
  });

  // Summary
  const failCount = checks.filter(c => c.status === 'fail').length;
  const warnCount = checks.filter(c => c.status === 'warn').length;
  const passCount = checks.filter(c => c.status === 'pass').length;

  let readyForLive = failCount === 0 && !IS_SIMULATION_SERVER && !isDemo;

  return NextResponse.json({
    summary: {
      pass: passCount,
      warn: warnCount,
      fail: failCount,
      readyForLive,
      currentMode: IS_SIMULATION_SERVER ? 'SIMULATION' : 'LIVE',
      kalshiEnv: isDemo ? 'DEMO' : 'PRODUCTION',
    },
    checks,
    instructions: readyForLive 
      ? 'All checks passed. System is ready for live trading.'
      : IS_SIMULATION_SERVER
        ? 'Set NEXT_PUBLIC_TAILSHARP_SIMULATION=false in .env.local to enable live trading'
        : 'Fix failing checks before enabling live trading',
  });
}


===== C:\Users\burba\tailsharp\src\app\api\test-matcher\route.ts =====

// src/app/api/test-matcher/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { KalshiClient } from '@/lib/kalshi/client';
import { findMatchingTicker, clearMarketCache } from '@/lib/kalshi/marketMatcher';

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const query = searchParams.get('q') || 'Trump wins 2024 election';
  const fresh = searchParams.get('fresh') === 'true';

  try {
    const client = new KalshiClient(
      process.env.KALSHI_API_KEY_ID!,
      process.env.KALSHI_PRIVATE_KEY!,
      process.env.KALSHI_USE_DEMO === 'true'
    );

    if (fresh) {
      clearMarketCache();
    }

    console.log('\n========== MARKET MATCHER TEST ==========');
    console.log('Query:', query);
    console.log('==========================================\n');

    const ticker = await findMatchingTicker(client, query);

    return NextResponse.json({
      query,
      matchedTicker: ticker,
      success: ticker !== null,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('Test matcher error:', error);
    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : 'Unknown error',
        query
      },
      { status: 500 }
    );
  }
}


===== C:\Users\burba\tailsharp\src\app\api\test-pipeline\route.ts =====

import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';
import { parseTransaction, isPredictionMarketTrade } from '@/lib/trading/transactionParser';
import { shouldCopyTrade } from '@/lib/trading/copyEngine';
import { executeCopyTrade } from '@/lib/trading/tradeExecutor';

const redis = new Redis(process.env.KV_REDIS_URL!);

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const marketDescription = body.market || 'Will Trump reduce inequality';
    const side = body.side || 'YES';
    const amount = body.amount || 50;
    const walletAddress = body.wallet || '4Nd1mBzzpXdGDDB4T';

    console.log('\n========== PIPELINE TEST ==========');
    console.log('Input:', { marketDescription, side, amount, walletAddress });
    console.log('====================================\n');

    const mockTransaction = {
      signature: 'test-' + Date.now(),
      timestamp: Math.floor(Date.now() / 1000),
      type: 'SWAP',
      description: marketDescription,
      source: 'POLYMARKET',
      fee: 5000,
      feePayer: walletAddress,
      nativeTransfers: [],
      tokenTransfers: [],
      accountData: [],
    };

    console.log('[Pipeline] Step 1: Checking if prediction market trade...');
    const isPrediction = isPredictionMarketTrade(mockTransaction);
    console.log('[Pipeline] Is prediction market trade:', isPrediction);

    if (!isPrediction) {
      return NextResponse.json({
        success: false,
        step: 'isPredictionMarketTrade',
        error: 'Transaction not recognized as prediction market trade',
      });
    }

    console.log('[Pipeline] Step 2: Parsing transaction...');
    const parsedTrade = parseTransaction(mockTransaction);
    console.log('[Pipeline] Parsed trade:', parsedTrade);

    if (!parsedTrade) {
      return NextResponse.json({
        success: false,
        step: 'parseTransaction',
        error: 'Failed to parse transaction',
      });
    }

    console.log('[Pipeline] Step 3: Checking copy settings...');
    const settingsData = await redis.get('copy-settings');
    const settings = settingsData ? JSON.parse(settingsData) : [];
    console.log('[Pipeline] Copy settings:', settings);

    const decision = shouldCopyTrade(parsedTrade, settings);
    console.log('[Pipeline] Copy decision:', decision);

    if (!decision.shouldCopy) {
      return NextResponse.json({
        success: false,
        step: 'shouldCopyTrade',
        error: decision.reason,
        settings: settings,
        hint: settings.length === 0 
          ? 'No copy settings found. Add a trader in /settings first.' 
          : 'Trader not found or not active in settings.',
      });
    }

    console.log('[Pipeline] Step 4: Executing copy trade...');
    const executedTrade = await executeCopyTrade(parsedTrade, decision);
    console.log('[Pipeline] Executed trade:', executedTrade);

    console.log('[Pipeline] Step 5: Saving to Redis...');
    await redis.lpush('executed-trades', JSON.stringify(executedTrade));
    await redis.ltrim('executed-trades', 0, 99);

    console.log('[Pipeline] Complete!');

    return NextResponse.json({
      success: true,
      trade: executedTrade,
      steps: {
        isPredictionMarketTrade: true,
        parseTransaction: true,
        shouldCopyTrade: true,
        executeCopyTrade: executedTrade.status === 'executed',
        savedToRedis: true,
      },
    });

  } catch (error) {
    console.error('[Pipeline] Error:', error);
    return NextResponse.json({
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    }, { status: 500 });
  }
}

export async function GET() {
  return NextResponse.json({
    usage: 'POST to this endpoint with optional body: { market, side, amount, wallet }',
    example: {
      market: 'Will Trump reduce inequality',
      side: 'YES',
      amount: 50,
      wallet: '4Nd1mBzzpXdGDDB4T',
    },
  });
}


===== C:\Users\burba\tailsharp\src\app\api\webhook\register\route.ts =====

// src/app/api/webhook/register/route.ts
import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';

const HELIUS_API_KEY = process.env.NEXT_PUBLIC_HELIUS_API_KEY;
const WEBHOOK_URL = process.env.NEXT_PUBLIC_APP_URL
  ? `${process.env.NEXT_PUBLIC_APP_URL}/api/webhook`
  : 'https://tail-sharp.vercel.app/api/webhook';

// Initialize Redis
const redis = new Redis(process.env.KV_REDIS_URL!);

// Test Redis connection
redis.ping().then(() => console.log('âœ… Redis connected')).catch((err) => console.error('âŒ Redis error:', err));

export async function POST(request: NextRequest) {
  try {
    const { walletAddress } = await request.json();

    console.log('Registering webhook for:', walletAddress);

    if (!walletAddress) {
      return NextResponse.json({ error: 'Wallet address required' }, { status: 400 });
    }

    if (!HELIUS_API_KEY) {
      return NextResponse.json({ error: 'Helius API key not configured' }, { status: 500 });
    }

    // First, get existing webhooks
    const existingResponse = await fetch(
      `https://api-mainnet.helius-rpc.com/v0/webhooks?api-key=${HELIUS_API_KEY}`
    );
    const existingWebhooks = await existingResponse.json();

    let heliusUrl: string;
    let method: string;
    let body: object;
    let webhookId: string;

    if (existingWebhooks.length > 0) {
      // UPDATE existing webhook - add new address to it
      webhookId = existingWebhooks[0].webhookID;
      
      // IMPORTANT: Fetch the LATEST state of this specific webhook to avoid race conditions
      const currentWebhookResponse = await fetch(
        `https://api-mainnet.helius-rpc.com/v0/webhooks/${webhookId}?api-key=${HELIUS_API_KEY}`
      );
      const currentWebhook = await currentWebhookResponse.json();
      const currentAddresses: string[] = currentWebhook.accountAddresses || [];
      
      // Store to Redis BEFORE checking if already tracked
      console.log('ðŸ’¾ Storing to Redis...');
      const settingsKey = 'copy-settings';
      const existingSettingsData = await redis.get(settingsKey);
      console.log('ðŸ“– Existing settings:', existingSettingsData);
      const settings = existingSettingsData ? JSON.parse(existingSettingsData) : [];

      if (!settings.find((s: any) => s.traderId === walletAddress)) {
        settings.push({
          traderId: walletAddress,
          isActive: true,
          allocationUsd: 100,
          maxPositionPercent: 25,
        });
        await redis.set(settingsKey, JSON.stringify(settings));
        console.log('âœ… Added to copy settings:', walletAddress);
      } else {
        console.log('â­ï¸ Already in copy settings:', walletAddress);
      }

      // Skip Helius update if already tracking this address
      if (currentAddresses.includes(walletAddress)) {
        return NextResponse.json({
          success: true,
          webhookId,
          message: `Already tracking wallet: ${walletAddress}`
        });
      }

      heliusUrl = `https://api-mainnet.helius-rpc.com/v0/webhooks/${webhookId}?api-key=${HELIUS_API_KEY}`;
      method = 'PUT';
      body = {
        webhookURL: WEBHOOK_URL,
        transactionTypes: ['ANY'],
        accountAddresses: [...currentAddresses, walletAddress],
        webhookType: 'enhanced',
      };
      console.log('Updating webhook:', webhookId, 'adding to', currentAddresses.length, 'existing addresses');
    } else {
      // CREATE new webhook
      heliusUrl = `https://api-mainnet.helius-rpc.com/v0/webhooks?api-key=${HELIUS_API_KEY}`;
      method = 'POST';
      body = {
        webhookURL: WEBHOOK_URL,
        transactionTypes: ['ANY'],
        accountAddresses: [walletAddress],
        webhookType: 'enhanced',
      };
      console.log('Creating new webhook');
      webhookId = '';
    }

    const response = await fetch(heliusUrl, {
      method,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    const responseText = await response.text();
    console.log('Helius response status:', response.status);
    console.log('Helius response:', responseText);

    if (!response.ok) {
      return NextResponse.json({
        error: 'Failed to register webhook',
        heliusError: responseText
      }, { status: 500 });
    }

    const data = JSON.parse(responseText);

    // For new webhooks, also store to Redis
    if (!existingWebhooks.length) {
      console.log('ðŸ’¾ Storing to Redis (new webhook)...');
      const settingsKey = 'copy-settings';
      const existingSettingsData = await redis.get(settingsKey);
      const settings = existingSettingsData ? JSON.parse(existingSettingsData) : [];

      if (!settings.find((s: any) => s.traderId === walletAddress)) {
        settings.push({
          traderId: walletAddress,
          isActive: true,
          allocationUsd: 100,
          maxPositionPercent: 25,
        });
        await redis.set(settingsKey, JSON.stringify(settings));
        console.log('âœ… Added to copy settings:', walletAddress);
      }
    }

    return NextResponse.json({
      success: true,
      webhookId: data.webhookID || webhookId,
      message: `Now tracking wallet: ${walletAddress}`
    });

  } catch (error) {
    console.error('Webhook registration error:', error);
    return NextResponse.json({ error: 'Internal server error', details: String(error) }, { status: 500 });
  }
}


===== C:\Users\burba\tailsharp\src\app\api\webhook\route.ts =====

// src/app/api/webhook/route.ts
import { NextRequest, NextResponse } from 'next/server';
import Redis from 'ioredis';
import { parseTransaction, isPredictionMarketTrade } from '@/lib/trading/transactionParser';
import { shouldCopyTrade } from '@/lib/trading/copyEngine';
import { executeCopyTrade } from '@/lib/trading/tradeExecutor';

// Initialize Redis with the URL directly
const redis = new Redis(process.env.KV_REDIS_URL!);

export async function POST(request: NextRequest) {
  try {
    const payload = await request.json();

    console.log('Webhook received:', JSON.stringify(payload, null, 2));

    const transactions = Array.isArray(payload) ? payload : [payload];

    for (const tx of transactions) {
      const enrichedTx = {
        signature: tx.signature,
        timestamp: tx.timestamp || Date.now() / 1000,
        type: tx.type,
        description: tx.description,
        source: tx.source,
        fee: tx.fee,
        feePayer: tx.feePayer,
        nativeTransfers: tx.nativeTransfers || [],
        tokenTransfers: tx.tokenTransfers || [],
        accountData: tx.accountData || [],
      };

      const walletAddress = tx.feePayer;
      if (walletAddress) {
        const key = `wallet:${walletAddress}:transactions`;
        
        await redis.lpush(key, JSON.stringify(enrichedTx));
        await redis.ltrim(key, 0, 49);
        await redis.expire(key, 60 * 60 * 24 * 30);

        console.log(`Transaction stored: ${tx.signature}`);

        if (isPredictionMarketTrade(tx)) {
          const parsedTrade = parseTransaction(tx);
          
          if (parsedTrade) {
            console.log('Prediction market trade detected:', parsedTrade);

            const settingsKey = 'copy-settings';
            const settingsData = await redis.get(settingsKey);
            const settings = settingsData ? JSON.parse(settingsData) : [];

            const decision = shouldCopyTrade(parsedTrade, settings);

            if (decision.shouldCopy) {
              console.log('Executing auto-copy trade:', decision);

              const executedTrade = await executeCopyTrade(parsedTrade, decision);

              const tradesKey = 'executed-trades';
              await redis.lpush(tradesKey, JSON.stringify(executedTrade));
              await redis.ltrim(tradesKey, 0, 99);

              console.log('Copy trade executed:', executedTrade);
            } else {
              console.log('Trade not copied:', decision.reason);
            }
          }
        }
      }
    }

    return NextResponse.json({ success: true });

  } catch (error) {
    console.error('Webhook processing error:', error);
    return NextResponse.json({ error: 'Failed to process webhook' }, { status: 500 });
  }
}

export async function GET(request: NextRequest) {
  const { searchParams } = new URL(request.url);
  const wallet = searchParams.get('wallet');

  if (!wallet) {
    return NextResponse.json({ error: 'Wallet address required' }, { status: 400 });
  }

  try {
    const key = `wallet:${wallet}:transactions`;
    const transactions = await redis.lrange(key, 0, 49);
    
    const parsed = transactions.map((tx: string) => JSON.parse(tx));

    return NextResponse.json({
      wallet,
      transactions: parsed,
      count: parsed.length
    });
  } catch (error) {
    console.error('Failed to fetch transactions:', error);
    return NextResponse.json({ error: 'Failed to fetch transactions' }, { status: 500 });
  }
}


===== C:\Users\burba\tailsharp\src\app\copy-trades\page.tsx =====

'use client';

import { useEffect, useState } from 'react';

interface ExecutedTrade {
  id: string;
  originalTrade: {
    market: string;
    side: 'YES' | 'NO';
    amount: number;
    price: number;
    walletAddress: string;
    signature: string;
    timestamp: number;
  };
  decision: {
    shouldCopy: boolean;
    positionSize: number;
  };
  status: 'pending' | 'executed' | 'failed';
  executedAt?: number;
  error?: string;
  ourSignature?: string;
}

export default function CopyTradesPage() {
  const [trades, setTrades] = useState<ExecutedTrade[]>([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchTrades();
    // Refresh every 5 seconds
    const interval = setInterval(fetchTrades, 5000);
    return () => clearInterval(interval);
  }, []);

  const fetchTrades = async () => {
    try {
      const res = await fetch('/api/copy-trades');
      const data = await res.json();
      setTrades(data.trades || []);
    } catch (error) {
      console.error('Failed to fetch trades:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatTime = (timestamp: number) => {
    return new Date(timestamp * 1000).toLocaleString();
  };

  const shortenAddress = (address: string) => {
    return `${address.slice(0, 4)}...${address.slice(-4)}`;
  };

  if (loading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 flex items-center justify-center">
        <div className="text-white text-xl">Loading trades...</div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-8">
      <div className="max-w-7xl mx-auto">
        <div className="mb-8">
          <h1 className="text-4xl font-bold text-white mb-2">Copy Trades</h1>
          <p className="text-gray-400">Automatically executed trades following your tracked traders</p>
        </div>

        {trades.length === 0 ? (
          <div className="bg-white/5 backdrop-blur-lg rounded-2xl border border-white/10 p-8 text-center">
            <p className="text-gray-400 text-lg">No copy trades yet</p>
            <p className="text-gray-500 text-sm mt-2">
              When your tracked traders make prediction market trades, they'll appear here
            </p>
          </div>
        ) : (
          <div className="space-y-4">
            {trades.map((trade) => (
              <div
                key={trade.id}
                className="bg-white/5 backdrop-blur-lg rounded-2xl border border-white/10 p-6 hover:bg-white/10 transition-all"
              >
                <div className="flex items-start justify-between mb-4">
                  <div>
                    <div className="flex items-center gap-3 mb-2">
                      <h3 className="text-xl font-semibold text-white">
                        {trade.originalTrade.market}
                      </h3>
                      <span
                        className={`px-3 py-1 rounded-full text-xs font-semibold ${
                          trade.originalTrade.side === 'YES'
                            ? 'bg-green-500/20 text-green-400'
                            : 'bg-red-500/20 text-red-400'
                        }`}
                      >
                        {trade.originalTrade.side}
                      </span>
                      <span
                        className={`px-3 py-1 rounded-full text-xs font-semibold ${
                          trade.status === 'executed'
                            ? 'bg-blue-500/20 text-blue-400'
                            : trade.status === 'failed'
                            ? 'bg-red-500/20 text-red-400'
                            : 'bg-yellow-500/20 text-yellow-400'
                        }`}
                      >
                        {trade.status}
                      </span>
                    </div>
                    <p className="text-gray-400 text-sm">
                      Following:{' '}
                      <a
                        href={`https://solscan.io/account/${trade.originalTrade.walletAddress}`}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-purple-400 hover:text-purple-300 underline"
                      >
                        {shortenAddress(trade.originalTrade.walletAddress)}
                      </a>
                    </p>
                  </div>
                  <div className="text-right">
                    <p className="text-2xl font-bold text-white">
                      ${trade.decision.positionSize}
                    </p>
                    <p className="text-gray-400 text-sm">
                      (${trade.originalTrade.amount} original)
                    </p>
                  </div>
                </div>

                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <p className="text-gray-500">Price</p>
                    <p className="text-white font-semibold">
                      ${trade.originalTrade.price.toFixed(2)}
                    </p>
                  </div>
                  <div>
                    <p className="text-gray-500">Executed At</p>
                    <p className="text-white font-semibold">
                      {trade.executedAt ? formatTime(trade.executedAt) : 'Pending'}
                    </p>
                  </div>
                </div>

                {trade.ourSignature && (
                  <div className="mt-4 pt-4 border-t border-white/10">
                    <p className="text-gray-500 text-xs mb-1">Transaction</p>
                    <a
                      href={`https://solscan.io/tx/${trade.ourSignature}`}
                      target="_blank"
                      rel="noopener noreferrer"
                      className="text-purple-400 hover:text-purple-300 text-sm font-mono underline"
                    >
                      {trade.ourSignature}
                    </a>
                  </div>
                )}

                {trade.error && (
                  <div className="mt-4 p-3 bg-red-500/10 border border-red-500/20 rounded-lg">
                    <p className="text-red-400 text-sm">{trade.error}</p>
                  </div>
                )}
              </div>
            ))}
          </div>
        )}
      </div>
    </div>
  );
}


===== C:\Users\burba\tailsharp\src\app\dashboard\page.tsx =====

// src/app/dashboard/page.tsx
'use client';

import { ConnectButton } from '@/components/wallet/ConnectButton';
import { useStore } from '@/lib/store/useStore';
import { useCopyTrades } from '@/lib/store/useCopyTrades';
import { useWallet } from '@solana/wallet-adapter-react';
import { NotificationBell } from '@/components/ui/NotificationBell';
import { CopyTradePanel } from '@/components/traders/CopyTradePanel';
import { TransactionFeed } from '@/components/traders/TransactionFeed';
import Link from 'next/link';
import Image from 'next/image';
import { useState, useEffect } from 'react';
import { IS_SIMULATION } from '@/lib/env';

export const dynamic = 'force-dynamic';

const DEV_MODE = true;

type RecentTrade = {
  id: string;
  originalTrade: {
    market: string;
    side: 'YES' | 'NO';
    amount: number;
    walletAddress: string;
    timestamp: number;
  };
  status: 'pending' | 'executed' | 'failed';
  kalshiTicker?: string;
  isSimulation?: boolean;
};

export default function Dashboard() {
  const { connected } = useWallet();
  const { copySettings, removeCopySettings, updateCopySettings } = useStore();
  const { simulatedTrades } = useCopyTrades();
  const [expandedTrader, setExpandedTrader] = useState<string | null>(null);
  const [recentTrades, setRecentTrades] = useState<RecentTrade[]>([]);
  const [tradesLoading, setTradesLoading] = useState(true);

  const isAuthenticated = DEV_MODE || connected;
  const pendingTradesCount = simulatedTrades.filter((t) => t.status === 'pending').length;

  useEffect(() => {
    async function loadRecentTrades() {
      try {
        const res = await fetch('/api/executed-trades');
        const data = await res.json();
        const trades = (data.trades || []) as RecentTrade[];
        setRecentTrades(trades.slice(0, 5));
      } catch {
        // ignore for now
      } finally {
        setTradesLoading(false);
      }
    }
    loadRecentTrades();
  }, []);

  if (!isAuthenticated) {
    return (
      <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
        <nav className="flex items-center justify-between px-6 py-4 border-b border-slate-800">
          <Link href="/" className="flex items-center gap-2">
            <Image src="/logo.jpg" alt="TailSharp" width={32} height={32} className="rounded-lg" />
            <span className="text-xl font-bold text-white">TailSharp</span>
          </Link>
          <ConnectButton />
        </nav>
        <div className="flex flex-col items-center justify-center py-32 px-6">
          <h1 className="text-3xl font-bold text-white mb-4">Connect Your Wallet</h1>
          <p className="text-slate-400 mb-8">Connect your wallet to view your dashboard</p>
          <ConnectButton />
        </div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
      <nav className="flex items-center justify-between px-6 py-4 border-b border-slate-800 sticky top-0 bg-slate-950/80 backdrop-blur-md z-50">
        <Link href="/" className="flex items-center gap-2">
          <Image src="/logo.jpg" alt="TailSharp" width={32} height={32} className="rounded-lg" />
          <span className="text-xl font-bold text-white">TailSharp</span>
        </Link>
        <div className="flex items-center gap-4">
          <Link href="/" className="text-slate-400 hover:text-white transition-colors">
            Home
          </Link>
          <Link href="/markets" className="text-slate-400 hover:text-white transition-colors">
            Markets
          </Link>
          <Link href="/explore" className="text-slate-400 hover:text-white transition-colors">
            Explore
          </Link>
          {DEV_MODE && (
            <span className="px-2 py-1 bg-yellow-500/20 text-yellow-400 text-xs rounded">
              DEV MODE
            </span>
          )}
          {IS_SIMULATION ? (
            <span className="inline-flex items-center rounded-full bg-amber-500/10 px-3 py-1 text-xs font-medium text-amber-300 ring-1 ring-amber-500/40">
              Mode: Simulation
            </span>
          ) : (
            <span className="inline-flex items-center rounded-full bg-emerald-500/10 px-3 py-1 text-xs font-medium text-emerald-300 ring-1 ring-emerald-500/40">
              Mode: Live
            </span>
          )}
          <NotificationBell />
          <ConnectButton />
        </div>
      </nav>

      <div className="max-w-7xl mx-auto px-6 py-12">
        <div className="flex items-center justify-between mb-8">
          <div>
            <h1 className="text-3xl font-bold text-white">Portfolio Dashboard</h1>
            <p className="text-slate-400 mt-1">Track and manage your copy trading positions</p>
          </div>
          {pendingTradesCount > 0 && (
            <div className="px-4 py-2 bg-blue-500/20 text-blue-400 rounded-lg text-sm font-medium animate-pulse">
              {pendingTradesCount} pending trade{pendingTradesCount > 1 ? 's' : ''}
            </div>
          )}
        </div>

        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-8">
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-5">
            <p className="text-slate-400 text-sm">Following</p>
            <p className="text-2xl font-bold text-white mt-1">{copySettings.length}</p>
          </div>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-5">
            <p className="text-slate-400 text-sm">Active Copies</p>
            <p className="text-2xl font-bold text-white mt-1">
              {copySettings.filter((s) => s.isActive).length}
            </p>
          </div>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-5">
            <p className="text-slate-400 text-sm">Total Allocated</p>
            <p className="text-2xl font-bold text-white mt-1">
              ${copySettings.reduce((sum, s) => sum + s.allocationUsd, 0).toLocaleString()}
            </p>
          </div>
          <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-5">
            <p className="text-slate-400 text-sm">Pending Trades</p>
            <p className="text-2xl font-bold text-blue-400 mt-1">{pendingTradesCount}</p>
          </div>
        </div>

        <div className="mb-8 rounded-lg border border-slate-800 bg-slate-900/80 p-4">
          <div className="flex items-center justify-between mb-2">
            <h2 className="text-sm font-semibold text-slate-100">Recent Trades</h2>
            <Link
              href="/executed-trades"
              className="text-xs font-medium text-blue-400 hover:text-blue-300"
            >
              View all
            </Link>
          </div>
          {tradesLoading && (
            <p className="text-xs text-slate-500">Loading trades...</p>
          )}
          {!tradesLoading && recentTrades.length === 0 && (
            <p className="text-xs text-slate-500">No trades executed yet.</p>
          )}
          {!tradesLoading && recentTrades.length > 0 && (
            <ul className="space-y-2 text-xs">
              {recentTrades.map((t) => {
                const dt = new Date(t.originalTrade.timestamp * 1000);
                return (
                  <li
                    key={t.id}
                    className="flex items-center justify-between border-t border-slate-800 pt-2 first:border-t-0 first:pt-0"
                  >
                    <div className="flex flex-col">
                      <span className="text-slate-100">
                        {t.originalTrade.side} - {t.originalTrade.market}
                      </span>
                      <span className="text-slate-500">
                        {t.originalTrade.amount} contracts - {t.originalTrade.walletAddress.slice(0, 4)}...{t.originalTrade.walletAddress.slice(-4)}
                      </span>
                    </div>
                    <div className="text-right">
                      <span className="block text-slate-500">
                        {dt.toLocaleTimeString()}
                      </span>
                      <span
                        className={
                          t.status === 'executed'
                            ? 'text-green-400'
                            : t.status === 'failed'
                            ? 'text-red-400'
                            : 'text-yellow-400'
                        }
                      >
                        {t.status}
                      </span>
                    </div>
                  </li>
                );
              })}
            </ul>
          )}
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <div className="lg:col-span-2">
            <h2 className="text-xl font-semibold text-white mb-4">Tracked Traders</h2>

            {copySettings.length === 0 ? (
              <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-8 text-center">
                <p className="text-slate-400 mb-4">You are not following any traders yet</p>
                <Link
                  href="/"
                  className="inline-block px-6 py-3 bg-gradient-to-r from-blue-500 to-teal-400 text-white font-semibold rounded-xl hover:opacity-90 transition-all"
                >
                  Find Traders
                </Link>
              </div>
            ) : (
              <div className="space-y-4">
                {copySettings.map((settings) => {
                  const isExpanded = expandedTrader === settings.traderId;

                  return (
                    <div
                      key={settings.traderId}
                      className="bg-slate-800/50 border border-slate-700 rounded-xl overflow-hidden"
                    >
                      <div className="p-5">
                        <div className="flex items-center justify-between mb-4">
                          <div className="flex items-center gap-3">
                            <div className="w-12 h-12 bg-gradient-to-r from-blue-500 to-teal-400 rounded-full flex items-center justify-center text-white font-bold text-lg">
                              {settings.traderId.slice(0, 2).toUpperCase()}
                            </div>
                            <div>
                              <p className="text-white font-medium font-mono">
                                {settings.traderId.slice(0, 6)}...{settings.traderId.slice(-6)}
                              </p>
                              <p className="text-sm">
                                {settings.isActive ? (
                                  <span className="text-green-400">Active</span>
                                ) : (
                                  <span className="text-slate-500">Paused</span>
                                )}
                              </p>
                            </div>
                          </div>
                          <div className="flex items-center gap-2">
                            <button
                              onClick={() => setExpandedTrader(isExpanded ? null : settings.traderId)}
                              className="text-slate-400 hover:text-white text-sm px-3 py-1 rounded-lg hover:bg-slate-700 transition-colors"
                            >
                              {isExpanded ? 'Hide' : 'View'} Activity
                            </button>
                            <button
                              onClick={() => removeCopySettings(settings.traderId)}
                              className="text-red-400 hover:text-red-300 text-sm px-3 py-1 rounded-lg hover:bg-red-500/10 transition-colors"
                            >
                              Unfollow
                            </button>
                          </div>
                        </div>

                        <div className="grid grid-cols-3 gap-3">
                          <div>
                            <label className="text-slate-500 text-xs block mb-1">Allocation (USD)</label>
                            <input
                              type="number"
                              value={settings.allocationUsd}
                              onChange={(e) =>
                                updateCopySettings(settings.traderId, {
                                  allocationUsd: Number(e.target.value),
                                })
                              }
                              className="w-full bg-slate-900 border border-slate-700 rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                          </div>
                          <div>
                            <label className="text-slate-500 text-xs block mb-1">Max Position %</label>
                            <input
                              type="number"
                              value={settings.maxPositionPercent}
                              onChange={(e) =>
                                updateCopySettings(settings.traderId, {
                                  maxPositionPercent: Number(e.target.value),
                                })
                              }
                              className="w-full bg-slate-900 border border-slate-700 rounded-lg px-3 py-2 text-white text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                            />
                          </div>
                          <div className="flex items-end">
                            <button
                              onClick={() =>
                                updateCopySettings(settings.traderId, {
                                  isActive: !settings.isActive,
                                })
                              }
                              className={`w-full py-2 rounded-lg text-sm font-medium transition-all ${
                                settings.isActive
                                  ? 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                                  : 'bg-gradient-to-r from-blue-500 to-teal-400 text-white hover:opacity-90'
                              }`}
                            >
                              {settings.isActive ? 'Pause' : 'Activate'}
                            </button>
                          </div>
                        </div>
                      </div>

                      {isExpanded && (
                        <div className="border-t border-slate-700 bg-slate-900/50 p-5">
                          <h3 className="text-sm font-medium text-slate-300 mb-3">Recent Activity</h3>
                          <TransactionFeed walletAddress={settings.traderId} limit={10} />
                        </div>
                      )}
                    </div>
                  );
                })}
              </div>
            )}
          </div>

          <div className="lg:col-span-1">
            <CopyTradePanel />
          </div>
        </div>
      </div>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\app\executed-trades\page.tsx =====

'use client';

import { useEffect, useState } from 'react';
import React from 'react';

type OriginalTrade = {
  market: string;
  side: 'YES' | 'NO';
  amount: number;
  price: number;
  walletAddress: string;
  signature: string;
  timestamp: number;
};

type CopyDecision = {
  shouldCopy: boolean;
  positionSize?: number;
  reason?: string;
};

type ExecutedTrade = {
  id: string;
  originalTrade: OriginalTrade;
  decision?: CopyDecision;
  status: 'pending' | 'executed' | 'failed';
  executedAt?: number;
  error?: string;
  ourOrderId?: string;
  kalshiTicker?: string;
  isSimulation?: boolean;
};

export default function ExecutedTradesPage() {
  const [trades, setTrades] = useState<ExecutedTrade[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [expandedTrade, setExpandedTrade] = useState<string | null>(null);

  useEffect(() => {
    async function loadTrades() {
      try {
        const res = await fetch('/api/executed-trades');
        const data = await res.json();
        setTrades(data.trades || []);
      } catch (e) {
        setError('Failed to load executed trades');
      } finally {
        setLoading(false);
      }
    }
    loadTrades();
  }, []);

  function getStatusBadge(trade: ExecutedTrade) {
    if (trade.status === 'executed') {
      return (
        <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-green-500/10 text-green-400 text-xs">
          <span className="w-1.5 h-1.5 rounded-full bg-green-400"></span>
          Executed
        </span>
      );
    }
    if (trade.status === 'failed') {
      const isNoMatch = trade.error?.includes('No matching');
      return (
        <span className={`inline-flex items-center gap-1 px-2 py-1 rounded-full text-xs ${
          isNoMatch 
            ? 'bg-amber-500/10 text-amber-400' 
            : 'bg-red-500/10 text-red-400'
        }`}>
          <span className={`w-1.5 h-1.5 rounded-full ${isNoMatch ? 'bg-amber-400' : 'bg-red-400'}`}></span>
          {isNoMatch ? 'No Match' : 'Failed'}
        </span>
      );
    }
    return (
      <span className="inline-flex items-center gap-1 px-2 py-1 rounded-full bg-yellow-500/10 text-yellow-400 text-xs">
        <span className="w-1.5 h-1.5 rounded-full bg-yellow-400 animate-pulse"></span>
        Pending
      </span>
    );
  }

  return (
    <main className="min-h-screen bg-slate-950 text-slate-100 px-6 py-8">
      <div className="max-w-7xl mx-auto">
        <div className="flex items-center justify-between mb-6">
          <div>
            <h1 className="text-2xl font-semibold">Executed Trades</h1>
            <p className="text-slate-400 text-sm mt-1">History of all copy trade attempts</p>
          </div>
          <div className="flex items-center gap-4 text-xs">
            <div className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-green-400"></span>
              <span className="text-slate-400">Executed</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-amber-400"></span>
              <span className="text-slate-400">No Match</span>
            </div>
            <div className="flex items-center gap-2">
              <span className="w-2 h-2 rounded-full bg-red-400"></span>
              <span className="text-slate-400">Failed</span>
            </div>
          </div>
        </div>

        {error && <p className="text-sm text-red-500 mb-4">{error}</p>}
        {loading && <p className="text-sm text-gray-400">Loading trades...</p>}

        {!loading && trades.length === 0 && (
          <div className="text-center py-12 border border-slate-800 rounded-lg">
            <p className="text-slate-400">No trades executed yet.</p>
            <p className="text-slate-500 text-sm mt-1">Trades will appear here when tracked wallets make prediction market trades.</p>
          </div>
        )}

        {!loading && trades.length > 0 && (
          <div className="overflow-x-auto border border-slate-800 rounded-lg">
            <table className="min-w-full text-xs md:text-sm">
              <thead className="bg-slate-900/80">
                <tr>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Time</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Trader</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Source Market</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Side</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Size</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Kalshi Match</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Status</th>
                  <th className="px-3 py-3 text-left font-medium text-slate-300">Mode</th>
                </tr>
              </thead>
              <tbody>
                {trades.map((t) => {
                  const dt = new Date((t.executedAt || t.originalTrade.timestamp) * 1000);
                  const isExpanded = expandedTrade === t.id;
                  const hasError = t.status === 'failed' && t.error;
                  
                  return (
                    <React.Fragment key={t.id}>
                      <tr 
                        className={`border-t border-slate-800 hover:bg-slate-900/50 cursor-pointer ${hasError ? 'bg-red-950/20' : ''}`}
                        onClick={() => setExpandedTrade(isExpanded ? null : t.id)}
                      >
                        <td className="px-3 py-3 whitespace-nowrap text-slate-300">
                          {dt.toLocaleString()}
                        </td>
                        <td className="px-3 py-3 font-mono text-slate-400">
                          {t.originalTrade.walletAddress.slice(0, 4)}...
                          {t.originalTrade.walletAddress.slice(-4)}
                        </td>
                        <td className="px-3 py-3 max-w-xs">
                          <span className="truncate block" title={t.originalTrade.market}>
                            {t.originalTrade.market}
                          </span>
                        </td>
                        <td className="px-3 py-3">
                          <span className={t.originalTrade.side === 'YES' ? 'text-green-400' : 'text-red-400'}>
                            {t.originalTrade.side}
                          </span>
                        </td>
                        <td className="px-3 py-3 text-slate-300">
                          {t.decision?.positionSize ?? t.originalTrade.amount}
                        </td>
                        <td className="px-3 py-3">
                          {t.kalshiTicker ? (
                            <span className="font-mono text-blue-400">{t.kalshiTicker}</span>
                          ) : (
                            <span className="text-slate-500">-</span>
                          )}
                        </td>
                        <td className="px-3 py-3">
                          {getStatusBadge(t)}
                        </td>
                        <td className="px-3 py-3">
                          <span className={`text-xs px-2 py-0.5 rounded ${
                            t.isSimulation 
                              ? 'bg-amber-500/10 text-amber-300' 
                              : 'bg-emerald-500/10 text-emerald-300'
                          }`}>
                            {t.isSimulation ? 'Sim' : 'Live'}
                          </span>
                        </td>
                      </tr>
                      {isExpanded && (
                        <tr className="border-t border-slate-800 bg-slate-900/30">
                          <td colSpan={8} className="px-4 py-3">
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-xs">
                              <div>
                                <p className="text-slate-500 mb-1">Trade ID</p>
                                <p className="font-mono text-slate-300">{t.id}</p>
                              </div>
                              <div>
                                <p className="text-slate-500 mb-1">Order ID</p>
                                <p className="font-mono text-slate-300">{t.ourOrderId || '-'}</p>
                              </div>
                              <div>
                                <p className="text-slate-500 mb-1">Original Amount</p>
                                <p className="text-slate-300">{t.originalTrade.amount} contracts</p>
                              </div>
                              <div>
                                <p className="text-slate-500 mb-1">Full Wallet</p>
                                <p className="font-mono text-slate-300 truncate">{t.originalTrade.walletAddress}</p>
                              </div>
                              {t.error && (
                                <div className="col-span-2 md:col-span-4">
                                  <p className="text-slate-500 mb-1">Error Details</p>
                                  <p className="text-red-400 bg-red-950/30 px-3 py-2 rounded border border-red-900/50">
                                    {t.error}
                                  </p>
                                </div>
                              )}
                            </div>
                          </td>
                        </tr>
                      )}
                    </React.Fragment>
                  );
                })}
              </tbody>
            </table>
          </div>
        )}
      </div>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\app\explore\page.tsx =====

// src/app/explore/page.tsx
'use client';

import { useState } from 'react';
import { ConnectButton } from '@/components/wallet/ConnectButton';
import { AddTrader } from '@/components/traders/AddTrader';
import { WalletDisplay } from '@/components/traders/WalletDisplay';
import { useStore } from '@/lib/store/useStore';
import { useAutoRefresh } from '@/lib/hooks/useAutoRefresh';
import { WalletData } from '@/lib/solana/tracker';
import Link from 'next/link';
import Image from 'next/image';

export default function Explore() {
  const [trackedWallets, setTrackedWallets] = useState<WalletData[]>([]);
  const [autoRefresh, setAutoRefresh] = useState(true);
  const { copySettings, addCopySettings, removeCopySettings } = useStore();

  const followingAddresses = copySettings.map((s) => s.traderId);

  // Auto-refresh every 15 seconds
  const { refreshWallets } = useAutoRefresh({
    wallets: trackedWallets,
    setWallets: setTrackedWallets,
    intervalMs: 15000,
    enabled: autoRefresh,
  });

  const handleAddTrader = (walletData: WalletData) => {
    if (trackedWallets.some((w) => w.address === walletData.address)) {
      return;
    }
    setTrackedWallets((prev) => [walletData, ...prev]);
  };

  const handleRemoveWallet = (address: string) => {
    setTrackedWallets((prev) => prev.filter((w) => w.address !== address));
  };

  const handleFollow = (address: string) => {
    if (followingAddresses.includes(address)) {
      removeCopySettings(address);
    } else {
      addCopySettings({
        traderId: address,
        allocationUsd: 100,
        maxPositionPercent: 25,
        stopLossPercent: 20,
        copyOpenPositions: false,
        isActive: true,
      });
    }
  };

  return (
    <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
      {/* Header */}
      <nav className="flex items-center justify-between px-6 py-4 border-b border-slate-800 sticky top-0 bg-slate-950/80 backdrop-blur-md z-50">
        <Link href="/" className="flex items-center gap-2">
          <Image src="/logo.jpg" alt="TailSharp" width={32} height={32} className="rounded-lg" />
          <span className="text-xl font-bold text-white">TailSharp</span>
        </Link>
        <div className="flex items-center gap-4">
          <Link href="/" className="text-slate-400 hover:text-white transition-colors">
            Leaderboard
          </Link>
          <Link href="/dashboard" className="text-slate-400 hover:text-white transition-colors">
            Dashboard
          </Link>
          <ConnectButton />
        </div>
      </nav>

      <div className="max-w-4xl mx-auto px-6 py-12">
        <div className="flex items-center justify-between mb-2">
          <h1 className="text-3xl font-bold text-white">Explore Wallets</h1>
          
          {/* Auto-refresh toggle */}
          {trackedWallets.length > 0 && (
            <div className="flex items-center gap-3">
              <button
                onClick={refreshWallets}
                className="p-2 text-slate-400 hover:text-white transition-colors"
                title="Refresh now"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
              </button>
              <label className="flex items-center gap-2 cursor-pointer">
                <div
                  onClick={() => setAutoRefresh(!autoRefresh)}
                  className={`relative w-10 h-6 rounded-full transition-colors ${
                    autoRefresh ? 'bg-blue-500' : 'bg-slate-700'
                  }`}
                >
                  <div
                    className={`absolute top-1 w-4 h-4 bg-white rounded-full transition-transform ${
                      autoRefresh ? 'translate-x-5' : 'translate-x-1'
                    }`}
                  />
                </div>
                <span className="text-slate-400 text-sm">Auto-refresh</span>
              </label>
            </div>
          )}
        </div>
        <p className="text-slate-400 mb-8">
          Track any Solana wallet to see their positions. Find sharps and follow them.
        </p>

        {/* Add Wallet Form */}
        <AddTrader onAddTrader={handleAddTrader} />

        {/* Example Wallets */}
        <div className="mb-8 p-4 bg-slate-800/30 border border-slate-700 rounded-xl">
          <p className="text-slate-400 text-sm mb-2">Try these example wallets:</p>
          <div className="flex flex-wrap gap-2">
            {[
              { addr: 'vines1vzrYbzLMRdu58ou5XTby4qAqVRLmqo36NKPTg', label: 'Vines' },
              { addr: 'GThUX1Atko4tqhN2NaiTazWSeFWMuiUvfFnyJyUghFMJ', label: 'Active Trader' },
            ].map(({ addr, label }) => (
              <button
                key={addr}
                onClick={async () => {
                  const { getWalletData } = await import('@/lib/solana/tracker');
                  const walletData = await getWalletData(addr);
                  handleAddTrader(walletData);
                }}
                className="text-xs bg-slate-700 hover:bg-slate-600 text-slate-300 px-3 py-1.5 rounded-lg transition-colors"
              >
                {label}
              </button>
            ))}
          </div>
        </div>

        {/* Tracked Wallets */}
        {trackedWallets.length > 0 && (
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <h2 className="text-xl font-semibold text-white">
                Tracked Wallets ({trackedWallets.length})
              </h2>
              {autoRefresh && (
                <span className="flex items-center gap-1 text-green-400 text-sm">
                  <span className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
                  Live
                </span>
              )}
            </div>
            {trackedWallets.map((wallet) => (
              <WalletDisplay
                key={wallet.address}
                wallet={wallet}
                onFollow={handleFollow}
                onRemove={handleRemoveWallet}
                isFollowing={followingAddresses.includes(wallet.address)}
              />
            ))}
          </div>
        )}

        {trackedWallets.length === 0 && (
          <div className="text-center py-16 text-slate-500">
            <p className="text-lg mb-2">No wallets tracked yet</p>
            <p className="text-sm">Enter a Solana wallet address above or click an example</p>
          </div>
        )}
      </div>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\app\markets\[id]\page.tsx =====



===== C:\Users\burba\tailsharp\src\app\markets\page.tsx =====

// src/app/markets/page.tsx
'use client';

import { useState, useEffect } from 'react';
import { ConnectButton } from '@/components/wallet/ConnectButton';
import { NotificationBell } from '@/components/ui/NotificationBell';
import { Market, getMarkets, formatPrice, formatVolume } from '@/lib/dflow/api';
import Link from 'next/link';
import Image from 'next/image';

const CATEGORIES = ['All', 'Crypto', 'Economics', 'Politics', 'Stocks'];

export default function Markets() {
  const [markets, setMarkets] = useState<Market[]>([]);
  const [loading, setLoading] = useState(true);
  const [selectedCategory, setSelectedCategory] = useState('All');
  const [searchQuery, setSearchQuery] = useState('');

  useEffect(() => {
    const fetchMarkets = async () => {
      setLoading(true);
      try {
        const data = await getMarkets();
        setMarkets(data);
      } catch (error) {
        console.error('Failed to fetch markets:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchMarkets();
  }, []);

  const filteredMarkets = markets.filter((market) => {
    const matchesCategory = selectedCategory === 'All' || market.category === selectedCategory;
    const matchesSearch = market.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                          market.ticker.toLowerCase().includes(searchQuery.toLowerCase());
    return matchesCategory && matchesSearch;
  });

  return (
    <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
      {/* Header */}
      <nav className="flex items-center justify-between px-6 py-4 border-b border-slate-800 sticky top-0 bg-slate-950/80 backdrop-blur-md z-50">
        <Link href="/" className="flex items-center gap-2">
          <Image src="/logo.jpg" alt="TailSharp" width={32} height={32} className="rounded-lg" />
          <span className="text-xl font-bold text-white">TailSharp</span>
        </Link>
        <div className="flex items-center gap-4">
          <Link href="/" className="text-slate-400 hover:text-white transition-colors">
            Leaderboard
          </Link>
          <Link href="/explore" className="text-slate-400 hover:text-white transition-colors">
            Explore
          </Link>
          <Link href="/dashboard" className="text-slate-400 hover:text-white transition-colors">
            Dashboard
          </Link>
          <NotificationBell />
          <ConnectButton />
        </div>
      </nav>

      <div className="max-w-6xl mx-auto px-6 py-12">
        <div className="mb-8">
          <h1 className="text-3xl font-bold text-white mb-2">Prediction Markets</h1>
          <p className="text-slate-400">Trade on real-world events via tokenized Kalshi markets</p>
        </div>

        {/* Filters */}
        <div className="flex flex-col md:flex-row gap-4 mb-8">
          {/* Search */}
          <div className="flex-1">
            <input
              type="text"
              placeholder="Search markets..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full bg-slate-800 border border-slate-700 rounded-xl px-4 py-3 text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
          </div>

          {/* Category Tabs */}
          <div className="flex gap-2">
            {CATEGORIES.map((category) => (
              <button
                key={category}
                onClick={() => setSelectedCategory(category)}
                className={`px-4 py-2 rounded-lg font-medium transition-all ${
                  selectedCategory === category
                    ? 'bg-blue-500 text-white'
                    : 'bg-slate-800 text-slate-400 hover:text-white'
                }`}
              >
                {category}
              </button>
            ))}
          </div>
        </div>

        {/* Markets Grid */}
        {loading ? (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {[...Array(4)].map((_, i) => (
              <div key={i} className="h-48 bg-slate-800/50 rounded-2xl animate-pulse" />
            ))}
          </div>
        ) : (
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {filteredMarkets.map((market) => (
              <Link
                key={market.id}
                href={`/markets/${market.id}`}
                className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 hover:border-slate-600 transition-all group"
              >
                {/* Header */}
                <div className="flex items-start justify-between mb-4">
                  <div className="flex-1">
                    <div className="flex items-center gap-2 mb-1">
                      <span className="px-2 py-0.5 bg-slate-700 text-slate-300 text-xs rounded">
                        {market.category}
                      </span>
                      <span className="text-slate-500 text-xs font-mono">{market.ticker}</span>
                    </div>
                    <h3 className="text-white font-semibold group-hover:text-blue-400 transition-colors">
                      {market.title}
                    </h3>
                  </div>
                </div>

                {/* Prices */}
                <div className="grid grid-cols-2 gap-4 mb-4">
                  <div className="bg-green-500/10 border border-green-500/30 rounded-xl p-3 text-center">
                    <p className="text-green-400 text-2xl font-bold">{formatPrice(market.yesPrice)}</p>
                    <p className="text-green-400/70 text-sm">Yes</p>
                  </div>
                  <div className="bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-center">
                    <p className="text-red-400 text-2xl font-bold">{formatPrice(market.noPrice)}</p>
                    <p className="text-red-400/70 text-sm">No</p>
                  </div>
                </div>

                {/* Stats */}
                <div className="flex items-center justify-between text-sm">
                  <div>
                    <span className="text-slate-500">24h Vol: </span>
                    <span className="text-white">{formatVolume(market.volume24h)}</span>
                  </div>
                  <div>
                    <span className="text-slate-500">Total: </span>
                    <span className="text-white">{formatVolume(market.totalVolume)}</span>
                  </div>
                  <div>
                    <span className="text-slate-500">Liquidity: </span>
                    <span className="text-white">{formatVolume(market.liquidity)}</span>
                  </div>
                </div>
              </Link>
            ))}
          </div>
        )}

        {!loading && filteredMarkets.length === 0 && (
          <div className="text-center py-16 text-slate-500">
            <p className="text-lg">No markets found</p>
            <p className="text-sm mt-1">Try a different search or category</p>
          </div>
        )}
      </div>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\app\settings\preflight\page.tsx =====

'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';

type Check = {
  name: string;
  status: 'pass' | 'fail' | 'warn';
  message: string;
};

type PreflightData = {
  summary: {
    pass: number;
    warn: number;
    fail: number;
    readyForLive: boolean;
    currentMode: string;
    kalshiEnv: string;
  };
  checks: Check[];
  instructions: string;
};

export default function PreflightPage() {
  const [data, setData] = useState<PreflightData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function loadPreflight() {
      try {
        const res = await fetch('/api/preflight');
        const json = await res.json();
        setData(json);
      } catch (e) {
        setError('Failed to load preflight checks');
      } finally {
        setLoading(false);
      }
    }
    loadPreflight();
  }, []);

  function getStatusIcon(status: string) {
    if (status === 'pass') return <span className="text-green-400">âœ“</span>;
    if (status === 'warn') return <span className="text-amber-400">âš </span>;
    return <span className="text-red-400">âœ—</span>;
  }

  function getStatusBg(status: string) {
    if (status === 'pass') return 'bg-green-500/10 border-green-500/30';
    if (status === 'warn') return 'bg-amber-500/10 border-amber-500/30';
    return 'bg-red-500/10 border-red-500/30';
  }

  return (
    <main className="min-h-screen bg-slate-950 text-slate-100 px-6 py-8">
      <div className="max-w-3xl mx-auto">
        <div className="mb-6">
          <Link href="/settings" className="text-slate-400 hover:text-white text-sm">
            â† Back to Settings
          </Link>
        </div>

        <h1 className="text-2xl font-semibold mb-2">Preflight Checks</h1>
        <p className="text-slate-400 text-sm mb-8">System status before enabling live trading</p>

        {loading && <p className="text-slate-400">Running checks...</p>}
        {error && <p className="text-red-400">{error}</p>}

        {data && (
          <>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-8">
              <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4 text-center">
                <p className="text-3xl font-bold text-green-400">{data.summary.pass}</p>
                <p className="text-slate-400 text-sm">Passed</p>
              </div>
              <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4 text-center">
                <p className="text-3xl font-bold text-amber-400">{data.summary.warn}</p>
                <p className="text-slate-400 text-sm">Warnings</p>
              </div>
              <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4 text-center">
                <p className="text-3xl font-bold text-red-400">{data.summary.fail}</p>
                <p className="text-slate-400 text-sm">Failed</p>
              </div>
              <div className="bg-slate-800/50 border border-slate-700 rounded-lg p-4 text-center">
                <p className={`text-xl font-bold ${data.summary.currentMode === 'SIMULATION' ? 'text-amber-400' : 'text-green-400'}`}>
                  {data.summary.currentMode}
                </p>
                <p className="text-slate-400 text-sm">Mode</p>
              </div>
            </div>

            <div className={`p-4 rounded-lg border mb-8 ${data.summary.readyForLive ? 'bg-green-500/10 border-green-500/30' : 'bg-amber-500/10 border-amber-500/30'}`}>
              <p className={data.summary.readyForLive ? 'text-green-400' : 'text-amber-400'}>
                {data.instructions}
              </p>
            </div>

            <div className="space-y-3">
              {data.checks.map((check, i) => (
                <div
                  key={i}
                  className={`flex items-center justify-between p-4 rounded-lg border ${getStatusBg(check.status)}`}
                >
                  <div className="flex items-center gap-3">
                    <span className="text-xl">{getStatusIcon(check.status)}</span>
                    <span className="font-medium">{check.name}</span>
                  </div>
                  <span className="text-sm text-slate-400">{check.message}</span>
                </div>
              ))}
            </div>

            <div className="mt-8 p-4 bg-slate-800/50 border border-slate-700 rounded-lg">
              <h3 className="font-medium mb-2">To enable live trading:</h3>
              <ol className="text-sm text-slate-400 space-y-1 list-decimal list-inside">
                <li>Get production API keys from Kalshi</li>
                <li>Set <code className="text-amber-400">KALSHI_USE_DEMO=false</code> in .env.local</li>
                <li>Set <code className="text-amber-400">NEXT_PUBLIC_TAILSHARP_SIMULATION=false</code> in .env.local</li>
                <li>Fund your Kalshi account</li>
                <li>Restart the dev server</li>
              </ol>
            </div>
          </>
        )}
      </div>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\app\settings\page.tsx =====

'use client';

import { useEffect, useState } from 'react';

type CopySetting = {
  traderId: string;
  isActive: boolean;
  allocationUsd: number;
  maxPositionPercent: number;
};

type ValidationErrors = {
  [traderId: string]: {
    allocationUsd?: string;
    maxPositionPercent?: string;
  };
};

export default function SettingsPage() {
  const [settings, setSettings] = useState<CopySetting[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});

  useEffect(() => {
    async function loadSettings() {
      try {
        const res = await fetch('/api/copy-settings');
        const data = await res.json();
        setSettings(data.settings || []);
      } catch (e) {
        setError('Failed to load settings');
      } finally {
        setLoading(false);
      }
    }
    loadSettings();
  }, []);

  // Validation function
  const validateField = (
    field: 'allocationUsd' | 'maxPositionPercent',
    value: number
  ): string | undefined => {
    if (field === 'allocationUsd') {
      if (isNaN(value)) return 'Invalid number';
      if (value < 0) return 'Must be â‰¥ 0';
    }

    if (field === 'maxPositionPercent') {
      if (isNaN(value)) return 'Invalid number';
      if (value < 0) return 'Must be â‰¥ 0';
      if (value > 100) return 'Must be â‰¤ 100';
    }

    return undefined;
  };

  // Validate all settings before save
  const validateAllSettings = (): boolean => {
    const errors: ValidationErrors = {};
    let isValid = true;

    settings.forEach((s) => {
      const allocError = validateField('allocationUsd', s.allocationUsd);
      const maxPosError = validateField('maxPositionPercent', s.maxPositionPercent);

      if (allocError || maxPosError) {
        isValid = false;
        errors[s.traderId] = {
          allocationUsd: allocError,
          maxPositionPercent: maxPosError,
        };
      }
    });

    setValidationErrors(errors);
    return isValid;
  };

  const updateField = (index: number, field: keyof CopySetting, value: any) => {
    const setting = settings[index];
    const numValue = Number(value);

    setSettings((prev) =>
      prev.map((s, i) =>
        i === index
          ? {
              ...s,
              [field]:
                field === 'allocationUsd' || field === 'maxPositionPercent'
                  ? numValue
                  : field === 'isActive'
                  ? Boolean(value)
                  : value,
            }
          : s
      )
    );

    // Validate numeric fields on change
    if (field === 'allocationUsd' || field === 'maxPositionPercent') {
      const validationError = validateField(field, numValue);

      setValidationErrors((prev) => ({
        ...prev,
        [setting.traderId]: {
          ...prev[setting.traderId],
          [field]: validationError,
        },
      }));
    }
  };

  const handleSave = async () => {
    // Validate before saving
    if (!validateAllSettings()) {
      setError('Please fix validation errors before saving');
      setSuccess(null);
      return;
    }

    setSaving(true);
    setError(null);
    setSuccess(null);
    try {
      const res = await fetch('/api/copy-settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings),
      });
      if (!res.ok) {
        throw new Error('Failed to save settings');
      }
      setSuccess('Settings saved');
    } catch (e) {
      setError('Failed to save settings');
    } finally {
      setSaving(false);
    }
  };

  // Check if any validation errors exist
  const hasErrors = Object.keys(validationErrors).some(
    (traderId) =>
      validationErrors[traderId].allocationUsd ||
      validationErrors[traderId].maxPositionPercent
  );

  if (loading) {
    return (
      <div className="p-6">
        <p className="text-sm text-gray-500">Loading settingsâ€¦</p>
      </div>
    );
  }

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-xl font-semibold">Copy Settings</h1>

      {error && <p className="text-sm text-red-500">{error}</p>}
      {success && <p className="text-sm text-green-500">{success}</p>}

      <div className="overflow-x-auto border rounded-lg">
        <table className="min-w-full text-sm">
          <thead className="bg-gray-50">
            <tr>
              <th className="px-4 py-2 text-left">Trader Address</th>
              <th className="px-4 py-2 text-left">Active</th>
              <th className="px-4 py-2 text-left">Allocation (USD)</th>
              <th className="px-4 py-2 text-left">Max Position (%)</th>
            </tr>
          </thead>
          <tbody>
            {settings.map((s, i) => (
              <tr key={s.traderId} className="border-t">
                <td className="px-4 py-2 font-mono text-xs">
                  {s.traderId}
                </td>
                <td className="px-4 py-2">
                  <input
                    type="checkbox"
                    checked={s.isActive}
                    onChange={(e) =>
                      updateField(i, 'isActive', e.target.checked)
                    }
                  />
                </td>
                <td className="px-4 py-2">
                  <div className="flex flex-col">
                    <input
                      type="number"
                      min="0"
                      step="0.01"
                      className={`w-24 rounded border px-2 py-1 text-sm focus:outline-none focus:ring-2 ${
                        validationErrors[s.traderId]?.allocationUsd
                          ? 'border-red-500 focus:ring-red-500'
                          : 'border-gray-300 focus:ring-blue-500'
                      }`}
                      value={s.allocationUsd}
                      onChange={(e) =>
                        updateField(i, 'allocationUsd', e.target.value)
                      }
                    />
                    {validationErrors[s.traderId]?.allocationUsd && (
                      <span className="text-xs text-red-600 mt-0.5">
                        {validationErrors[s.traderId].allocationUsd}
                      </span>
                    )}
                  </div>
                </td>
                <td className="px-4 py-2">
                  <div className="flex flex-col">
                    <input
                      type="number"
                      min="0"
                      max="100"
                      step="1"
                      className={`w-20 rounded border px-2 py-1 text-sm focus:outline-none focus:ring-2 ${
                        validationErrors[s.traderId]?.maxPositionPercent
                          ? 'border-red-500 focus:ring-red-500'
                          : 'border-gray-300 focus:ring-blue-500'
                      }`}
                      value={s.maxPositionPercent}
                      onChange={(e) =>
                        updateField(i, 'maxPositionPercent', e.target.value)
                      }
                    />
                    {validationErrors[s.traderId]?.maxPositionPercent && (
                      <span className="text-xs text-red-600 mt-0.5">
                        {validationErrors[s.traderId].maxPositionPercent}
                      </span>
                    )}
                  </div>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <button
        onClick={handleSave}
        disabled={saving || hasErrors}
        className="rounded bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 disabled:opacity-50"
      >
        {saving ? 'Savingâ€¦' : 'Save Settings'}
      </button>
    </div>
  );
}


===== C:\Users\burba\tailsharp\src\app\layout.tsx =====

// src/app/layout.tsx
import type { Metadata } from 'next';
import { Geist, Geist_Mono } from 'next/font/google';
import './globals.css';
import { WalletProvider } from '@/components/wallet/WalletProvider';
import { QueryProvider } from '@/components/providers/QueryProvider';
import { TransactionWatcher } from '@/components/providers/TransactionWatcher';
export const dynamic = 'force-dynamic';

const geistSans = Geist({
  variable: '--font-geist-sans',
  subsets: ['latin'],
});

const geistMono = Geist_Mono({
  variable: '--font-geist-mono',
  subsets: ['latin'],
});

export const metadata: Metadata = {
  title: 'TailSharp | Copy Trading for Prediction Markets',
  description: 'Copy the sharps. Auto-mirror top prediction market traders on tokenized Kalshi markets via Solana.',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <QueryProvider>
          <WalletProvider>
            <TransactionWatcher />
            {children}
          </WalletProvider>
        </QueryProvider>
      </body>
    </html>
  );
}


===== C:\Users\burba\tailsharp\src\app\page.tsx =====

// src/app/page.tsx
import { ConnectButton } from '@/components/wallet/ConnectButton';
import { Leaderboard } from '@/components/traders/Leaderboard';
import { NotificationBell } from '@/components/ui/NotificationBell';
import Link from 'next/link';
import Image from 'next/image';

export default function Home() {
  return (
    <main className="min-h-screen bg-gradient-to-br from-slate-950 via-slate-900 to-slate-950">
      {/* Header */}
      <nav className="flex items-center justify-between px-6 py-4 border-b border-slate-800 sticky top-0 bg-slate-950/80 backdrop-blur-md z-50">
        <div className="flex items-center gap-2">
          <Image src="/logo.jpg" alt="TailSharp" width={32} height={32} className="rounded-lg" />
          <span className="text-xl font-bold text-white">TailSharp</span>
        </div>
        <div className="flex items-center gap-4">
          <Link href="/markets" className="text-slate-400 hover:text-white transition-colors">
            Markets
          </Link>
          <Link href="/explore" className="text-slate-400 hover:text-white transition-colors">
            Explore
          </Link>
          <Link href="/dashboard" className="text-slate-400 hover:text-white transition-colors">
            Dashboard
          </Link>
          <Link href="/copy-trades" className="text-slate-400 hover:text-white transition-colors">
            Copy Trades
          </Link>
          <Link href="/executed-trades" className="text-slate-400 hover:text-white transition-colors">
            Trades
          </Link>
          <Link href="/settings" className="text-slate-400 hover:text-white transition-colors">
            Settings
          </Link>
          <NotificationBell />
          <ConnectButton />
        </div>
      </nav>

      {/* Hero */}
      <section className="flex flex-col items-center justify-center px-6 py-20 text-center">
        <h1 className="text-5xl md:text-6xl font-bold text-white mb-6">
          Copy the{' '}
          <span className="text-transparent bg-clip-text bg-gradient-to-r from-blue-500 to-teal-400">
            sharps
          </span>
          .
          <br />
          Trade the future.
        </h1>
        <p className="text-xl text-slate-400 max-w-2xl mb-10">
          Auto-mirror top prediction market traders on tokenized Kalshi markets via Solana.
          One click. Real-time. On-chain.
        </p>
        <div className="flex gap-4">
          <Link
            href="/markets"
            className="px-8 py-4 bg-gradient-to-r from-blue-500 to-teal-400 text-white font-semibold rounded-xl hover:opacity-90 transition-all"
          >
            View Markets
          </Link>
          <Link
            href="/explore"
            className="px-8 py-4 bg-slate-800 text-white font-semibold rounded-xl hover:bg-slate-700 transition-all"
          >
            Track Wallets
          </Link>
        </div>
      </section>

      {/* Stats */}
      <section className="grid grid-cols-1 md:grid-cols-3 gap-6 px-6 max-w-5xl mx-auto mb-12">
        <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 text-center">
          <p className="text-3xl font-bold text-white">$10B+</p>
          <p className="text-slate-400 mt-1">Monthly Volume</p>
        </div>
        <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 text-center">
          <p className="text-3xl font-bold text-white">100+</p>
          <p className="text-slate-400 mt-1">Markets Live</p>
        </div>
        <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 text-center">
          <p className="text-3xl font-bold text-white">24/7</p>
          <p className="text-slate-400 mt-1">Auto-Copy</p>
        </div>
      </section>

      {/* Leaderboard */}
      <Leaderboard />

      {/* Footer */}
      <footer className="border-t border-slate-800 mt-20 py-8 px-6 text-center text-slate-500 text-sm">
        <p>Built with Kalshi Builder Codes on Solana</p>
      </footer>
    </main>
  );
}


===== C:\Users\burba\tailsharp\src\components\providers\QueryProvider.tsx =====

// src/components/providers/QueryProvider.tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { ReactNode, useState } from 'react';

interface Props {
  children: ReactNode;
}

export const QueryProvider = ({ children }: Props) => {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000, // 1 minute
            refetchOnWindowFocus: false,
          },
        },
      })
  );

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};


===== C:\Users\burba\tailsharp\src\components\providers\TransactionWatcher.tsx =====

'use client';

import { useTransactionWatcher } from '@/lib/hooks/useTransactionWatcher';
import { useTradeNotifications } from '@/lib/hooks/useTradeNotifications';

export const TransactionWatcher = () => {
  useTransactionWatcher(true);
  useTradeNotifications(true);
  return null;
};


===== C:\Users\burba\tailsharp\src\components\traders\AddTrader.tsx =====

// src/components/traders/AddTrader.tsx
'use client';

import { FC, useState } from 'react';
import { isValidSolanaAddress, getWalletData, WalletData } from '@/lib/solana/tracker';

interface AddTraderProps {
  onAddTrader: (walletData: WalletData) => void;
}

export const AddTrader: FC<AddTraderProps> = ({ onAddTrader }) => {
  const [address, setAddress] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);

    if (!address.trim()) {
      setError('Please enter a wallet address');
      return;
    }

    if (!isValidSolanaAddress(address.trim())) {
      setError('Invalid Solana wallet address');
      return;
    }

    setLoading(true);

    try {
      const walletData = await getWalletData(address.trim());
      onAddTrader(walletData);
      setAddress('');
    } catch (err) {
      console.error('Failed to fetch wallet:', err);
      setError('Failed to fetch wallet data. Try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="mb-8">
      <div className="flex flex-col md:flex-row gap-3">
        <div className="flex-1">
          <input
            type="text"
            value={address}
            onChange={(e) => setAddress(e.target.value)}
            placeholder="Enter Solana wallet address to track..."
            className="w-full bg-slate-800 border border-slate-700 rounded-xl px-4 py-3 text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
          />
          {error && <p className="text-red-400 text-sm mt-2">{error}</p>}
        </div>
        <button
          type="submit"
          disabled={loading}
          className="px-6 py-3 bg-gradient-to-r from-blue-500 to-teal-400 text-white font-semibold rounded-xl hover:opacity-90 transition-all disabled:opacity-50 disabled:cursor-not-allowed whitespace-nowrap"
        >
          {loading ? (
            <span className="flex items-center gap-2">
              <svg className="animate-spin h-5 w-5" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
              </svg>
              Loading...
            </span>
          ) : (
            'Track Wallet'
          )}
        </button>
      </div>
    </form>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\CopyTradeCard.tsx =====

// src/components/traders/CopyTradeCard.tsx
'use client';

import { FC } from 'react';
import { SimulatedTrade, formatUsd } from '@/lib/solana/copyTrade';

interface CopyTradeCardProps {
  trade: SimulatedTrade;
  onExecute: (id: string) => void;
  onReject: (id: string) => void;
  autoExecute?: boolean;
}

export const CopyTradeCard: FC<CopyTradeCardProps> = ({
  trade,
  onExecute,
  onReject,
  autoExecute = false,
}) => {
  const isBuy = trade.action === 'BUY';

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-4 hover:border-slate-600 transition-all">
      {/* Header */}
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2">
          <span
            className={`px-2 py-1 text-xs font-bold rounded ${
              isBuy
                ? 'bg-green-500/20 text-green-400'
                : 'bg-red-500/20 text-red-400'
            }`}
          >
            {trade.action}
          </span>
          <span className="text-white font-semibold">{trade.tokenSymbol}</span>
        </div>
        <span className="text-slate-500 text-xs">
          {trade.timestamp.toLocaleTimeString()}
        </span>
      </div>

      {/* Trade Details */}
      <div className="space-y-2 mb-4">
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Trader</span>
          <span className="text-white font-mono">{trade.traderShortAddress}</span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Trader Amount</span>
          <span className="text-white">
            {trade.traderAmount.toLocaleString()} {trade.tokenSymbol}
          </span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Your Copy Amount</span>
          <span className={`font-semibold ${isBuy ? 'text-green-400' : 'text-red-400'}`}>
            {trade.yourAmount.toLocaleString()} {trade.tokenSymbol}
          </span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Proportion</span>
          <span className="text-slate-300">{trade.proportionPercent.toFixed(2)}%</span>
        </div>
        <div className="flex justify-between text-sm border-t border-slate-700 pt-2 mt-2">
          <span className="text-slate-400">Estimated Cost</span>
          <span className="text-white font-semibold">{formatUsd(trade.estimatedCost)}</span>
        </div>
      </div>

      {/* Actions */}
      {trade.status === 'pending' && (
        <div className="flex gap-2">
          {autoExecute ? (
            <div className="flex-1 py-2 bg-yellow-500/20 text-yellow-400 text-center text-sm rounded-lg">
              Auto-executing...
            </div>
          ) : (
            <>
              <button
                onClick={() => onExecute(trade.id)}
                className="flex-1 py-2 bg-gradient-to-r from-blue-500 to-teal-400 text-white text-sm font-semibold rounded-lg hover:opacity-90 transition-all"
              >
                Execute
              </button>
              <button
                onClick={() => onReject(trade.id)}
                className="flex-1 py-2 bg-slate-700 text-slate-300 text-sm font-semibold rounded-lg hover:bg-slate-600 transition-all"
              >
                Skip
              </button>
            </>
          )}
        </div>
      )}

      {trade.status === 'executed' && (
        <div className="py-2 bg-green-500/20 text-green-400 text-center text-sm rounded-lg">
          âœ“ Executed
        </div>
      )}

      {trade.status === 'failed' && (
        <div className="py-2 bg-red-500/20 text-red-400 text-center text-sm rounded-lg">
          âœ— Failed
        </div>
      )}
    </div>
  );
};



===== C:\Users\burba\tailsharp\src\components\traders\CopyTradePanel.tsx =====

// src/components/traders/CopyTradePanel.tsx
'use client';

import { FC, useState } from 'react';
import { useCopyTrades } from '@/lib/store/useCopyTrades';
import { CopyTradeCard } from './CopyTradeCard';
import { MarketCopyTradeCard } from './MarketCopyTradeCard';
import { useNotifications } from '@/lib/store/useNotifications';
import { SimulatedTrade } from '@/lib/solana/copyTrade';
import { MarketCopyTrade, generateMarketCopyTrade, executeMarketCopyTrade } from '@/lib/dflow/copyTradeMarkets';
import { useStore } from '@/lib/store/useStore';

// Type guard to check if trade is a market trade
const isMarketTrade = (trade: SimulatedTrade): trade is MarketCopyTrade => {
  return 'marketId' in trade;
};

export const CopyTradePanel: FC = () => {
  const { simulatedTrades, executedTrades, executeTrade, rejectTrade, clearSimulatedTrades, addSimulatedTrade } =
    useCopyTrades();
  const { addNotification } = useNotifications();
  const { copySettings } = useStore();
  const [simulating, setSimulating] = useState(false);

  const pendingTrades = simulatedTrades.filter((t) => t.status === 'pending');

  const handleExecute = async (id: string) => {
    const trade = simulatedTrades.find((t) => t.id === id);
    
    if (trade && isMarketTrade(trade)) {
      // Execute market trade
      const result = await executeMarketCopyTrade(trade);
      
      if (result.success) {
        executeTrade(id);
        addNotification({
          type: 'info',
          title: 'âœ… Market Order Executed',
          message: `Bought ${trade.contracts} ${trade.side.toUpperCase()} on ${trade.marketTicker}`,
        });
      } else {
        addNotification({
          type: 'error',
          title: 'âŒ Order Failed',
          message: result.error || 'Failed to execute trade',
        });
      }
    } else {
      // Regular token trade
      executeTrade(id);
      if (trade) {
        addNotification({
          type: 'info',
          title: 'âœ… Trade Executed',
          message: `${trade.action} ${trade.yourAmount.toFixed(4)} ${trade.tokenSymbol}`,
        });
      }
    }
  };

  const handleReject = (id: string) => {
    rejectTrade(id);
  };

  // Simulate a market copy trade
  const simulateMarketTrade = async () => {
    setSimulating(true);
    
    // Get a random active trader
    const activeSettings = copySettings.filter((s) => s.isActive);
    if (activeSettings.length === 0) {
      addNotification({
        type: 'warning',
        title: 'âš ï¸ No Active Traders',
        message: 'Follow and activate a trader first',
      });
      setSimulating(false);
      return;
    }

    const settings = activeSettings[Math.floor(Math.random() * activeSettings.length)];
    
    // Random market and side
    const marketIds = ['fed-rate-dec-2025', 'btc-100k-2025', 'cpi-jan-2026', 'eth-5k-q1-2026'];
    const marketId = marketIds[Math.floor(Math.random() * marketIds.length)];
    const side = Math.random() > 0.5 ? 'yes' : 'no';
    const traderContracts = Math.floor(Math.random() * 500) + 50;

    const trade = await generateMarketCopyTrade(
      settings.traderId,
      marketId,
      side as 'yes' | 'no',
      traderContracts,
      settings
    );

    if (trade) {
      addSimulatedTrade(trade);
      addNotification({
        type: 'trade',
        title: 'ðŸ”” Market Copy Trade',
        message: `${trade.traderShortAddress} bought ${side.toUpperCase()} on ${trade.marketTicker}`,
      });
    }

    setSimulating(false);
  };

  // Simulate regular token trade
  const simulateTokenTrade = () => {
    const testTrade: SimulatedTrade = {
      id: `test-${Date.now()}`,
      traderId: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',
      traderShortAddress: '7xKX...gAsU',
      tokenMint: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v',
      tokenSymbol: 'USDC',
      tokenName: 'USD Coin',
      action: Math.random() > 0.5 ? 'BUY' : 'SELL',
      traderAmount: Math.floor(Math.random() * 1000) + 100,
      yourAmount: Math.floor(Math.random() * 100) + 10,
      yourAllocation: 100,
      proportionPercent: 1,
      estimatedCost: Math.floor(Math.random() * 50) + 10,
      timestamp: new Date(),
      status: 'pending',
    };

    addSimulatedTrade(testTrade);
    addNotification({
      type: 'trade',
      title: 'ðŸ”” Copy Trade Detected',
      message: `${testTrade.traderShortAddress} ${testTrade.action === 'BUY' ? 'bought' : 'sold'} ${testTrade.tokenSymbol}`,
    });
  };

  return (
    <div className="bg-slate-800/30 border border-slate-700 rounded-2xl p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-6">
        <div>
          <h2 className="text-xl font-bold text-white">Copy Trades</h2>
          <p className="text-slate-400 text-sm mt-1">
            {pendingTrades.length} pending Â· {executedTrades.length} executed
          </p>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={simulateMarketTrade}
            disabled={simulating}
            className="text-sm text-green-400 hover:text-green-300 transition-colors disabled:opacity-50"
          >
            {simulating ? '...' : '+ Market'}
          </button>
          <button
            onClick={simulateTokenTrade}
            className="text-sm text-yellow-400 hover:text-yellow-300 transition-colors"
          >
            + Token
          </button>
          {simulatedTrades.length > 0 && (
            <button
              onClick={clearSimulatedTrades}
              className="text-sm text-slate-400 hover:text-red-400 transition-colors"
            >
              Clear
            </button>
          )}
        </div>
      </div>

      {/* Pending Trades */}
      {pendingTrades.length > 0 && (
        <div className="mb-6">
          <h3 className="text-sm font-semibold text-slate-400 mb-3">Pending</h3>
          <div className="space-y-3">
            {pendingTrades.map((trade) => (
              isMarketTrade(trade) ? (
                <MarketCopyTradeCard
                  key={trade.id}
                  trade={trade}
                  onExecute={handleExecute}
                  onReject={handleReject}
                />
              ) : (
                <CopyTradeCard
                  key={trade.id}
                  trade={trade}
                  onExecute={handleExecute}
                  onReject={handleReject}
                />
              )
            ))}
          </div>
        </div>
      )}

      {/* Executed Trades */}
      {executedTrades.length > 0 && (
        <div>
          <h3 className="text-sm font-semibold text-slate-400 mb-3">Recently Executed</h3>
          <div className="space-y-3">
            {executedTrades.slice(0, 5).map((trade) => (
              isMarketTrade(trade) ? (
                <MarketCopyTradeCard
                  key={trade.id}
                  trade={trade}
                  onExecute={() => {}}
                  onReject={() => {}}
                />
              ) : (
                <CopyTradeCard
                  key={trade.id}
                  trade={trade}
                  onExecute={() => {}}
                  onReject={() => {}}
                />
              )
            ))}
          </div>
        </div>
      )}

      {/* Empty State */}
      {simulatedTrades.length === 0 && executedTrades.length === 0 && (
        <div className="text-center py-8 text-slate-500">
          <p>No copy trades yet</p>
          <p className="text-sm mt-1">Click &quot;+ Market&quot; to simulate a prediction market trade</p>
        </div>
      )}
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\Leaderboard.tsx =====

// src/components/traders/Leaderboard.tsx
'use client';

import { FC, useState } from 'react';
import { TraderCard } from './TraderCard';
import { useStore } from '@/lib/store/useStore';
import type { Trader } from '@/types';

// Mock data for now - we'll replace with real on-chain data
const MOCK_TRADERS: Trader[] = [
  {
    address: '7xKXtg2CW87d97TXJSDpbD5jBkheTqA83TZRuJosgAsU',
    displayName: 'SharpWhale',
    avatar: null,
    followers: 1243,
    isVerified: true,
    stats: {
      totalTrades: 156,
      winRate: 68.5,
      roi: 42.3,
      sharpeRatio: 1.8,
      avgPositionSize: 2500,
      totalVolume: 390000,
      lastActiveAt: new Date(),
    },
    positions: [
      {
        id: '1',
        marketId: 'fed-rate-dec',
        marketTitle: 'Fed cuts rates in December?',
        outcome: 'YES',
        contracts: 500,
        avgPrice: 0.65,
        currentPrice: 0.72,
        pnl: 35,
        pnlPercent: 10.7,
        openedAt: new Date(),
      },
    ],
  },
  {
    address: '9aE476sH92Vz7DMPyq5WLPkrKWivxeuTKEFKd2sZZcde',
    displayName: 'PredictorAlpha',
    avatar: null,
    followers: 892,
    isVerified: true,
    stats: {
      totalTrades: 234,
      winRate: 61.2,
      roi: 28.7,
      sharpeRatio: 1.5,
      avgPositionSize: 1800,
      totalVolume: 421200,
      lastActiveAt: new Date(),
    },
    positions: [
      {
        id: '2',
        marketId: 'btc-100k',
        marketTitle: 'BTC above $100k by year end?',
        outcome: 'YES',
        contracts: 300,
        avgPrice: 0.45,
        currentPrice: 0.58,
        pnl: 39,
        pnlPercent: 28.8,
        openedAt: new Date(),
      },
    ],
  },
  {
    address: '4Nd1mBQtrMJVYVfKf2PJy9NZUZdTAsp7D4xWLs4gDB4T',
    displayName: 'EventEdge',
    avatar: null,
    followers: 567,
    isVerified: false,
    stats: {
      totalTrades: 89,
      winRate: 72.1,
      roi: 55.2,
      sharpeRatio: 2.1,
      avgPositionSize: 3200,
      totalVolume: 284800,
      lastActiveAt: new Date(),
    },
    positions: [],
  },
  {
    address: '6sbzC1eH4FTujJXWj51eQe25cYvr4xfXbJ1vAj7j2k5J',
    displayName: null,
    avatar: null,
    followers: 234,
    isVerified: false,
    stats: {
      totalTrades: 312,
      winRate: 58.9,
      roi: 19.4,
      sharpeRatio: 1.2,
      avgPositionSize: 950,
      totalVolume: 296400,
      lastActiveAt: new Date(),
    },
    positions: [
      {
        id: '3',
        marketId: 'inflation-3',
        marketTitle: 'CPI above 3% in January?',
        outcome: 'NO',
        contracts: 200,
        avgPrice: 0.38,
        currentPrice: 0.32,
        pnl: -12,
        pnlPercent: -15.7,
        openedAt: new Date(),
      },
    ],
  },
];

type SortOption = 'roi' | 'winRate' | 'volume' | 'followers';

export const Leaderboard: FC = () => {
  const [sortBy, setSortBy] = useState<SortOption>('roi');
  const { copySettings, addCopySettings, removeCopySettings } = useStore();

  const followingAddresses = copySettings.map((s) => s.traderId);

  const handleFollow = (address: string) => {
    if (followingAddresses.includes(address)) {
      removeCopySettings(address);
    } else {
      addCopySettings({
        traderId: address,
        allocationUsd: 100,
        maxPositionPercent: 25,
        stopLossPercent: 20,
        copyOpenPositions: false,
        isActive: true,
      });
    }
  };

  const sortedTraders = [...MOCK_TRADERS].sort((a, b) => {
    switch (sortBy) {
      case 'roi':
        return b.stats.roi - a.stats.roi;
      case 'winRate':
        return b.stats.winRate - a.stats.winRate;
      case 'volume':
        return b.stats.totalVolume - a.stats.totalVolume;
      case 'followers':
        return b.followers - a.followers;
      default:
        return 0;
    }
  });

  return (
    <section className="px-6 py-12 max-w-6xl mx-auto">
      {/* Header */}
      <div className="flex flex-col md:flex-row md:items-center justify-between mb-8 gap-4">
        <div>
          <h2 className="text-3xl font-bold text-white">Top Traders</h2>
          <p className="text-slate-400 mt-1">Follow the sharps and auto-copy their positions</p>
        </div>

        {/* Sort Dropdown */}
        <div className="flex items-center gap-2">
          <span className="text-slate-400 text-sm">Sort by:</span>
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value as SortOption)}
            className="bg-slate-800 border border-slate-700 text-white rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
          >
            <option value="roi">ROI</option>
            <option value="winRate">Win Rate</option>
            <option value="volume">Volume</option>
            <option value="followers">Followers</option>
          </select>
        </div>
      </div>

      {/* Trader Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        {sortedTraders.map((trader) => (
          <TraderCard
            key={trader.address}
            trader={trader}
            onFollow={handleFollow}
            isFollowing={followingAddresses.includes(trader.address)}
          />
        ))}
      </div>
    </section>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\MarketCopyTradeCard.tsx =====

// src/components/traders/MarketCopyTradeCard.tsx
'use client';

import { FC } from 'react';
import { MarketCopyTrade } from '@/lib/dflow/copyTradeMarkets';
import { formatPrice } from '@/lib/dflow/api';
import Link from 'next/link';

interface MarketCopyTradeCardProps {
  trade: MarketCopyTrade;
  onExecute: (id: string) => void;
  onReject: (id: string) => void;
}

export const MarketCopyTradeCard: FC<MarketCopyTradeCardProps> = ({
  trade,
  onExecute,
  onReject,
}) => {
  const isYes = trade.side === 'yes';

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-xl p-4 hover:border-slate-600 transition-all">
      {/* Header */}
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center gap-2">
          <span
            className={`px-2 py-1 text-xs font-bold rounded ${
              isYes
                ? 'bg-green-500/20 text-green-400'
                : 'bg-red-500/20 text-red-400'
            }`}
          >
            {trade.side.toUpperCase()}
          </span>
          <span className="text-white font-semibold">{trade.marketTicker}</span>
        </div>
        <span className="text-slate-500 text-xs">
          {trade.timestamp.toLocaleTimeString()}
        </span>
      </div>

      {/* Market Title */}
      <Link 
        href={`/markets/${trade.marketId}`}
        className="text-slate-300 text-sm hover:text-blue-400 transition-colors block mb-3"
      >
        {trade.marketTitle}
      </Link>

      {/* Trade Details */}
      <div className="space-y-2 mb-4">
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Trader</span>
          <span className="text-white font-mono">{trade.traderShortAddress}</span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Trader Contracts</span>
          <span className="text-white">{trade.traderAmount}</span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Your Contracts</span>
          <span className={`font-semibold ${isYes ? 'text-green-400' : 'text-red-400'}`}>
            {trade.contracts}
          </span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Price</span>
          <span className="text-slate-300">{formatPrice(trade.pricePerContract)}</span>
        </div>
        <div className="flex justify-between text-sm border-t border-slate-700 pt-2 mt-2">
          <span className="text-slate-400">Total Cost</span>
          <span className="text-white font-semibold">${trade.estimatedCost.toFixed(2)}</span>
        </div>
        <div className="flex justify-between text-sm">
          <span className="text-slate-400">Potential Payout</span>
          <span className="text-white">${trade.contracts.toFixed(2)}</span>
        </div>
      </div>

      {/* Actions */}
      {trade.status === 'pending' && (
        <div className="flex gap-2">
          <button
            onClick={() => onExecute(trade.id)}
            className={`flex-1 py-2 text-white text-sm font-semibold rounded-lg transition-all ${
              isYes
                ? 'bg-green-500 hover:bg-green-600'
                : 'bg-red-500 hover:bg-red-600'
            }`}
          >
            Execute {trade.side.toUpperCase()}
          </button>
          <button
            onClick={() => onReject(trade.id)}
            className="flex-1 py-2 bg-slate-700 text-slate-300 text-sm font-semibold rounded-lg hover:bg-slate-600 transition-all"
          >
            Skip
          </button>
        </div>
      )}

      {trade.status === 'executed' && (
        <div className="py-2 bg-green-500/20 text-green-400 text-center text-sm rounded-lg">
          âœ“ Executed
        </div>
      )}
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\TraderCard.tsx =====

// src/components/traders/TraderCard.tsx
'use client';

import { FC } from 'react';
import type { Trader } from '@/types';

interface TraderCardProps {
  trader: Trader;
  onFollow: (address: string) => void;
  isFollowing: boolean;
}

export const TraderCard: FC<TraderCardProps> = ({ trader, onFollow, isFollowing }) => {
  const roiColor = trader.stats.roi >= 0 ? 'text-green-400' : 'text-red-400';
  const roiSign = trader.stats.roi >= 0 ? '+' : '';

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6 hover:border-slate-600 transition-all duration-200">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 bg-gradient-to-r from-blue-500 to-teal-400 rounded-full flex items-center justify-center text-white font-bold text-lg">
            {trader.displayName?.[0] || trader.address.slice(0, 2)}
          </div>
          <div>
            <div className="flex items-center gap-2">
              <p className="text-white font-semibold">
                {trader.displayName || `${trader.address.slice(0, 4)}...${trader.address.slice(-4)}`}
              </p>
              {trader.isVerified && (
                <span className="text-blue-400">
                  <svg className="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                </span>
              )}
            </div>
            <p className="text-slate-500 text-sm">{trader.followers} followers</p>
          </div>
        </div>
        <button
          onClick={() => onFollow(trader.address)}
          className={`px-4 py-2 rounded-lg font-medium transition-all duration-200 ${
            isFollowing
              ? 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              : 'bg-gradient-to-r from-blue-500 to-teal-400 text-white hover:opacity-90'
          }`}
        >
          {isFollowing ? 'Following' : 'Follow'}
        </button>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-3 gap-4">
        <div className="text-center p-3 bg-slate-900/50 rounded-xl">
          <p className={`text-xl font-bold ${roiColor}`}>
            {roiSign}{trader.stats.roi.toFixed(1)}%
          </p>
          <p className="text-slate-500 text-sm">ROI</p>
        </div>
        <div className="text-center p-3 bg-slate-900/50 rounded-xl">
          <p className="text-xl font-bold text-white">
            {trader.stats.winRate.toFixed(0)}%
          </p>
          <p className="text-slate-500 text-sm">Win Rate</p>
        </div>
        <div className="text-center p-3 bg-slate-900/50 rounded-xl">
          <p className="text-xl font-bold text-white">
            {trader.stats.totalTrades}
          </p>
          <p className="text-slate-500 text-sm">Trades</p>
        </div>
      </div>

      {/* Active Positions Preview */}
      {trader.positions.length > 0 && (
        <div className="mt-4 pt-4 border-t border-slate-700">
          <p className="text-slate-400 text-sm mb-2">Active Positions</p>
          <div className="space-y-2">
            {trader.positions.slice(0, 2).map((position) => (
              <div
                key={position.id}
                className="flex items-center justify-between text-sm"
              >
                <span className="text-slate-300 truncate max-w-[200px]">
                  {position.marketTitle}
                </span>
                <span className={position.pnl >= 0 ? 'text-green-400' : 'text-red-400'}>
                  {position.pnl >= 0 ? '+' : ''}{position.pnlPercent.toFixed(1)}%
                </span>
              </div>
            ))}
          </div>
        </div>
      )}
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\TransactionFeed.tsx =====

// src/components/traders/TransactionFeed.tsx
'use client';

import { FC, useEffect, useState } from 'react';
import {
  Transaction,
  getCombinedTransactions,
  formatTimeAgo,
  shortenSignature,
} from '@/lib/solana/transactions';

interface TransactionFeedProps {
  walletAddress: string;
  limit?: number;
}

export const TransactionFeed: FC<TransactionFeedProps> = ({
  walletAddress,
  limit = 5,
}) => {
  const [transactions, setTransactions] = useState<Transaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchTransactions = async () => {
      setLoading(true);
      setError(null);

      try {
        const txs = await getCombinedTransactions(walletAddress, limit);
        setTransactions(txs);
      } catch (err) {
        console.error('Failed to fetch transactions:', err);
        setError('Failed to load transactions');
      } finally {
        setLoading(false);
      }
    };

    fetchTransactions();

    // Refresh every 30 seconds
    const interval = setInterval(fetchTransactions, 30000);
    return () => clearInterval(interval);
  }, [walletAddress, limit]);

  if (loading && transactions.length === 0) {
    return (
      <div className="animate-pulse space-y-2">
        {[...Array(3)].map((_, i) => (
          <div key={i} className="h-12 bg-slate-800 rounded-lg" />
        ))}
      </div>
    );
  }

  if (error) {
    return <div className="text-red-400 text-sm">{error}</div>;
  }

  if (transactions.length === 0) {
    return <div className="text-slate-500 text-sm">No recent transactions</div>;
  }

  return (
    <div className="space-y-2">
      {transactions.map((tx) => (
        <a
          key={tx.signature}
          href={`https://solscan.io/tx/${tx.signature}`}
          target="_blank"
          rel="noopener noreferrer"
          className="flex items-center justify-between bg-slate-900/50 hover:bg-slate-900/70 rounded-lg p-3 transition-colors group"
        >
          <div className="flex items-center gap-3">
            <div
              className={`w-2 h-2 rounded-full ${
                tx.success ? 'bg-green-400' : 'bg-red-400'
              }`}
            />
            <div className="flex flex-col">
              <span className="text-slate-300 font-mono text-sm">
                {shortenSignature(tx.signature)}
              </span>
              {tx.description && (
                <span className="text-slate-500 text-xs truncate max-w-[200px]">
                  {tx.description}
                </span>
              )}
            </div>
          </div>
          <div className="flex items-center gap-3">
            <span className="text-slate-500 text-sm">
              {formatTimeAgo(tx.timestamp)}
            </span>
            <svg
              className="w-4 h-4 text-slate-600 group-hover:text-slate-400 transition-colors"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
              />
            </svg>
          </div>
        </a>
      ))}
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\traders\WalletDisplay.tsx =====

// src/components/traders/WalletDisplay.tsx
'use client';

import { FC, useState } from 'react';
import { WalletData } from '@/lib/solana/tracker';
import { formatSol } from '@/lib/solana/connection';
import { getTokenInfo, formatTokenAmount } from '@/lib/solana/tokens';
import { TransactionFeed } from './TransactionFeed';

interface WalletDisplayProps {
  wallet: WalletData;
  onFollow: (address: string) => void;
  onRemove: (address: string) => void;
  isFollowing: boolean;
}

export const WalletDisplay: FC<WalletDisplayProps> = ({
  wallet,
  onFollow,
  onRemove,
  isFollowing,
}) => {
  const [activeTab, setActiveTab] = useState<'tokens' | 'transactions'>('tokens');
  const shortAddress = `${wallet.address.slice(0, 4)}...${wallet.address.slice(-4)}`;

  return (
    <div className="bg-slate-800/50 border border-slate-700 rounded-2xl p-6">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <div className="flex items-center gap-3">
          <div className="w-12 h-12 bg-gradient-to-r from-purple-500 to-pink-500 rounded-full flex items-center justify-center text-white font-bold text-lg">
            {wallet.address.slice(0, 2)}
          </div>
          <div>
            <p className="text-white font-semibold">{shortAddress}</p>
            <p className="text-slate-500 text-sm">
              Updated {wallet.lastUpdated.toLocaleTimeString()}
            </p>
          </div>
        </div>
        <div className="flex items-center gap-2">
          <button
            onClick={() => onFollow(wallet.address)}
            className={`px-4 py-2 rounded-lg font-medium transition-all duration-200 ${
              isFollowing
                ? 'bg-slate-700 text-slate-300 hover:bg-slate-600'
                : 'bg-gradient-to-r from-blue-500 to-teal-400 text-white hover:opacity-90'
            }`}
          >
            {isFollowing ? 'Following' : 'Follow'}
          </button>
          <button
            onClick={() => onRemove(wallet.address)}
            className="p-2 text-slate-500 hover:text-red-400 transition-colors"
            title="Remove"
          >
            <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-4">
        <div className="bg-slate-900/50 rounded-xl p-4">
          <p className="text-slate-500 text-sm">SOL Balance</p>
          <p className="text-xl font-bold text-white">{formatSol(wallet.solBalance)}</p>
        </div>
        <div className="bg-slate-900/50 rounded-xl p-4">
          <p className="text-slate-500 text-sm">Token Positions</p>
          <p className="text-xl font-bold text-white">{wallet.tokens.length}</p>
        </div>
        <div className="bg-slate-900/50 rounded-xl p-4">
          <p className="text-slate-500 text-sm">Known Tokens</p>
          <p className="text-xl font-bold text-green-400">
            {wallet.tokens.filter((t) => getTokenInfo(t.mint).isKnown).length}
          </p>
        </div>
        <div className="bg-slate-900/50 rounded-xl p-4">
          <p className="text-slate-500 text-sm">Unknown</p>
          <p className="text-xl font-bold text-slate-400">
            {wallet.tokens.filter((t) => !getTokenInfo(t.mint).isKnown).length}
          </p>
        </div>
      </div>

      {/* Tabs */}
      <div className="flex gap-2 mb-4 border-b border-slate-700">
        <button
          onClick={() => setActiveTab('tokens')}
          className={`px-4 py-2 text-sm font-medium transition-colors border-b-2 -mb-px ${
            activeTab === 'tokens'
              ? 'border-blue-500 text-white'
              : 'border-transparent text-slate-400 hover:text-white'
          }`}
        >
          Tokens ({wallet.tokens.length})
        </button>
        <button
          onClick={() => setActiveTab('transactions')}
          className={`px-4 py-2 text-sm font-medium transition-colors border-b-2 -mb-px ${
            activeTab === 'transactions'
              ? 'border-blue-500 text-white'
              : 'border-transparent text-slate-400 hover:text-white'
          }`}
        >
          Transactions
        </button>
      </div>

      {/* Tab Content */}
      {activeTab === 'tokens' && (
        <>
          {wallet.tokens.length > 0 ? (
            <div className="space-y-2 max-h-64 overflow-y-auto">
              {wallet.tokens.map((token, index) => {
                const info = getTokenInfo(token.mint);
                return (
                  <div
                    key={`${token.mint}-${index}`}
                    className="flex items-center justify-between bg-slate-900/50 rounded-lg p-3 hover:bg-slate-900/70 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div
                        className={`w-10 h-10 rounded-full flex items-center justify-center text-sm font-bold ${
                          info.isKnown
                            ? 'bg-gradient-to-r from-blue-500 to-teal-400 text-white'
                            : 'bg-slate-700 text-slate-400'
                        }`}
                      >
                        {info.symbol.slice(0, 2)}
                      </div>
                      <div>
                        <p className="text-white font-medium">{info.symbol}</p>
                        <p className="text-slate-500 text-xs">
                          {info.isKnown ? info.name : `${token.mint.slice(0, 12)}...`}
                        </p>
                      </div>
                    </div>
                    <div className="text-right">
                      <p className="text-white font-medium">
                        {formatTokenAmount(token.uiAmount, token.decimals)}
                      </p>
                      {info.isKnown && (
                        <p className="text-slate-500 text-xs">{info.symbol}</p>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          ) : (
            <div className="text-center py-4 text-slate-500">
              No token positions found
            </div>
          )}
        </>
      )}

      {activeTab === 'transactions' && (
        <TransactionFeed walletAddress={wallet.address} limit={5} />
      )}

      {/* Full Address */}
      <div className="mt-4 pt-4 border-t border-slate-700 flex items-center justify-between">
        <p className="text-slate-500 text-xs font-mono truncate max-w-[80%]">{wallet.address}</p>
        <a
          href={`https://solscan.io/account/${wallet.address}`}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-400 hover:text-blue-300 text-xs"
        >
          Solscan â†—
        </a>
      </div>
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\ui\NotificationBell.tsx =====

// src/components/ui/NotificationBell.tsx
'use client';

import { FC, useState, useRef, useEffect } from 'react';
import { useNotifications, Notification } from '@/lib/store/useNotifications';

export const NotificationBell: FC = () => {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const { notifications, unreadCount, markAsRead, markAllAsRead, clearAll, addNotification } =
    useNotifications();

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const formatTime = (date: Date) => {
    const now = new Date();
    const diff = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diff < 60) return 'Just now';
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    return date.toLocaleDateString();
  };

  const handleNotificationClick = (notification: Notification) => {
    markAsRead(notification.id);

    if (notification.txSignature) {
      window.open(`https://solscan.io/tx/${notification.txSignature}`, '_blank');
    }
  };

  // Test function - remove in production
  const sendTestNotification = () => {
    addNotification({
      type: 'trade',
      title: 'ðŸ”” New Transaction Detected',
      message: 'Test trader just made a move!',
      walletAddress: '7xKX...gAsU',
      txSignature: '5UfDuX7hXrPTHGJGdWKvjNcTzTYZ5vKzLpMtNjZMvE5VGxqv1GNHsJQqhE1Qb3q5v',
    });
  };

  return (
    <div className="relative" ref={dropdownRef}>
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-slate-400 hover:text-white transition-colors"
      >
        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9"
          />
        </svg>
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 w-5 h-5 bg-red-500 text-white text-xs font-bold rounded-full flex items-center justify-center animate-pulse">
            {unreadCount > 9 ? '9+' : unreadCount}
          </span>
        )}
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-slate-800 border border-slate-700 rounded-xl shadow-xl z-50 overflow-hidden">
          {/* Header */}
          <div className="flex items-center justify-between px-4 py-3 border-b border-slate-700">
            <h3 className="text-white font-semibold">Notifications</h3>
            <div className="flex items-center gap-2">
              {/* Test button - remove in production */}
              <button
                onClick={sendTestNotification}
                className="text-xs text-yellow-400 hover:text-yellow-300"
              >
                Test
              </button>
              {unreadCount > 0 && (
                <button
                  onClick={markAllAsRead}
                  className="text-xs text-slate-400 hover:text-white"
                >
                  Mark all read
                </button>
              )}
              {notifications.length > 0 && (
                <button
                  onClick={clearAll}
                  className="text-xs text-slate-400 hover:text-red-400"
                >
                  Clear
                </button>
              )}
            </div>
          </div>

          {/* Notifications List */}
          <div className="max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="px-4 py-8 text-center text-slate-500">
                <p>No notifications yet</p>
                <p className="text-xs mt-1">Follow traders to get alerts</p>
              </div>
            ) : (
              notifications.map((notification) => (
                <div
                  key={notification.id}
                  onClick={() => handleNotificationClick(notification)}
                  className={`px-4 py-3 border-b border-slate-700/50 cursor-pointer hover:bg-slate-700/50 transition-colors ${
                    !notification.read ? 'bg-slate-700/30' : ''
                  }`}
                >
                  <div className="flex items-start gap-3">
                    <div
                      className={`w-2 h-2 mt-2 rounded-full flex-shrink-0 ${
                        notification.type === 'trade'
                          ? 'bg-green-400'
                          : notification.type === 'warning'
                          ? 'bg-yellow-400'
                          : notification.type === 'error'
                          ? 'bg-red-400'
                          : 'bg-blue-400'
                      }`}
                    />
                    <div className="flex-1 min-w-0">
                      <p className="text-white text-sm font-medium">
                        {notification.title}
                      </p>
                      <p className="text-slate-400 text-xs mt-0.5 truncate">
                        {notification.message}
                      </p>
                      <p className="text-slate-500 text-xs mt-1">
                        {formatTime(notification.timestamp)}
                      </p>
                    </div>
                    {notification.txSignature && (
                      <svg
                        className="w-4 h-4 text-slate-500 flex-shrink-0"
                        fill="none"
                        stroke="currentColor"
                        viewBox="0 0 24 24"
                      >
                        <path
                          strokeLinecap="round"
                          strokeLinejoin="round"
                          strokeWidth={2}
                          d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                        />
                      </svg>
                    )}
                  </div>
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
};


===== C:\Users\burba\tailsharp\src\components\wallet\ConnectButton.tsx =====

// src/components/wallet/ConnectButton.tsx
'use client';

import { useWallet } from '@solana/wallet-adapter-react';
import { useWalletModal } from '@solana/wallet-adapter-react-ui';
import { useCallback, useMemo } from 'react';

export const ConnectButton = () => {
  const { publicKey, wallet, disconnect, connecting, connected } = useWallet();
  const { setVisible } = useWalletModal();

  // Truncate wallet address for display
  const displayAddress = useMemo(() => {
    if (!publicKey) return '';
    const base58 = publicKey.toBase58();
    return `${base58.slice(0, 4)}...${base58.slice(-4)}`;
  }, [publicKey]);

  const handleClick = useCallback(() => {
    if (connected) {
      disconnect();
    } else {
      setVisible(true);
    }
  }, [connected, disconnect, setVisible]);

  return (
    <button
      onClick={handleClick}
      disabled={connecting}
      className="px-6 py-3 bg-gradient-to-r from-blue-500 to-teal-400 text-white font-semibold rounded-xl hover:opacity-90 transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {connecting ? (
        'Connecting...'
      ) : connected ? (
        <span className="flex items-center gap-2">
          <span className="w-2 h-2 bg-green-400 rounded-full animate-pulse" />
          {displayAddress}
        </span>
      ) : (
        'Connect Wallet'
      )}
    </button>
  );
};


===== C:\Users\burba\tailsharp\src\components\wallet\WalletProvider.tsx =====

// src/components/wallet/WalletProvider.tsx
'use client';

import { FC, ReactNode, useMemo, useCallback } from 'react';
import {
  ConnectionProvider,
  WalletProvider as SolanaWalletProvider,
} from '@solana/wallet-adapter-react';
import { WalletModalProvider } from '@solana/wallet-adapter-react-ui';
import {
  PhantomWalletAdapter,
  SolflareWalletAdapter,
  CoinbaseWalletAdapter,
} from '@solana/wallet-adapter-wallets';
import { WalletError } from '@solana/wallet-adapter-base';

// Import wallet adapter styles
import '@solana/wallet-adapter-react-ui/styles.css';

interface Props {
  children: ReactNode;
}

export const WalletProvider: FC<Props> = ({ children }) => {
  // RPC endpoint
  const endpoint = useMemo(
    () => process.env.NEXT_PUBLIC_SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com',
    []
  );

  // Initialize wallets
  const wallets = useMemo(
    () => [
      new PhantomWalletAdapter(),
      new SolflareWalletAdapter(),
      new CoinbaseWalletAdapter(),
    ],
    []
  );

  // Handle wallet errors gracefully
  const onError = useCallback((error: WalletError) => {
    console.error('Wallet error:', error.message);
    
    // Check if it's a "wallet not installed" type error
    if (error.name === 'WalletNotReadyError') {
      // The modal already shows install links, so we just log it
      console.log('Wallet not installed - user will see install prompt');
    }
  }, []);

  return (
    <ConnectionProvider endpoint={endpoint}>
      <SolanaWalletProvider wallets={wallets} onError={onError} autoConnect>
        <WalletModalProvider>
          {children}
        </WalletModalProvider>
      </SolanaWalletProvider>
    </ConnectionProvider>
  );
};


===== C:\Users\burba\tailsharp\src\lib\dflow\api.ts =====

// src/lib/dflow/api.ts

const DFLOW_API_BASE = 'https://api.dflow.net';

export interface Market {
  id: string;
  ticker: string;
  title: string;
  description: string;
  category: string;
  status: 'open' | 'closed' | 'resolved';
  expirationDate: string;
  yesPrice: number;
  noPrice: number;
  volume24h: number;
  totalVolume: number;
  liquidity: number;
}

export interface Position {
  marketId: string;
  side: 'yes' | 'no';
  quantity: number;
  avgPrice: number;
  currentValue: number;
  pnl: number;
  pnlPercent: number;
}

export interface OrderRequest {
  marketId: string;
  side: 'yes' | 'no';
  quantity: number;
  price?: number; // Limit price, omit for market order
  type: 'market' | 'limit';
}

export interface OrderResponse {
  orderId: string;
  status: 'pending' | 'filled' | 'partial' | 'cancelled';
  filledQuantity: number;
  avgFillPrice: number;
  timestamp: string;
}

// Mock data until API is live
const MOCK_MARKETS: Market[] = [
  {
    id: 'fed-rate-dec-2025',
    ticker: 'FED-DEC25',
    title: 'Fed cuts rates in December 2025?',
    description: 'Will the Federal Reserve cut interest rates at their December 2025 meeting?',
    category: 'Economics',
    status: 'open',
    expirationDate: '2025-12-18T19:00:00Z',
    yesPrice: 0.72,
    noPrice: 0.28,
    volume24h: 125000,
    totalVolume: 2450000,
    liquidity: 89000,
  },
  {
    id: 'btc-100k-2025',
    ticker: 'BTC-100K',
    title: 'Bitcoin above $100k by year end?',
    description: 'Will Bitcoin trade above $100,000 at any point before January 1, 2026?',
    category: 'Crypto',
    status: 'open',
    expirationDate: '2025-12-31T23:59:59Z',
    yesPrice: 0.65,
    noPrice: 0.35,
    volume24h: 340000,
    totalVolume: 8900000,
    liquidity: 245000,
  },
  {
    id: 'cpi-jan-2026',
    ticker: 'CPI-JAN26',
    title: 'CPI above 3% in January 2026?',
    description: 'Will the Consumer Price Index year-over-year reading be above 3% for January 2026?',
    category: 'Economics',
    status: 'open',
    expirationDate: '2026-02-12T13:30:00Z',
    yesPrice: 0.41,
    noPrice: 0.59,
    volume24h: 67000,
    totalVolume: 1230000,
    liquidity: 56000,
  },
  {
    id: 'eth-5k-q1-2026',
    ticker: 'ETH-5K-Q1',
    title: 'Ethereum above $5k in Q1 2026?',
    description: 'Will Ethereum trade above $5,000 at any point in Q1 2026?',
    category: 'Crypto',
    status: 'open',
    expirationDate: '2026-03-31T23:59:59Z',
    yesPrice: 0.38,
    noPrice: 0.62,
    volume24h: 89000,
    totalVolume: 1890000,
    liquidity: 78000,
  },
  {
    id: 'sp500-6000-2025',
    ticker: 'SPX-6000',
    title: 'S&P 500 closes above 6000 in 2025?',
    description: 'Will the S&P 500 index close above 6000 at least once before end of 2025?',
    category: 'Stocks',
    status: 'open',
    expirationDate: '2025-12-31T21:00:00Z',
    yesPrice: 0.82,
    noPrice: 0.18,
    volume24h: 210000,
    totalVolume: 5670000,
    liquidity: 189000,
  },
  {
    id: 'trump-approval-50',
    ticker: 'TRUMP-50',
    title: 'Trump approval above 50% by March?',
    description: 'Will President Trump\'s approval rating be above 50% in any major poll by March 31, 2026?',
    category: 'Politics',
    status: 'open',
    expirationDate: '2026-03-31T23:59:59Z',
    yesPrice: 0.34,
    noPrice: 0.66,
    volume24h: 156000,
    totalVolume: 3450000,
    liquidity: 134000,
  },
];

// API mode flag
const USE_MOCK = true; // Set to false when DFlow API is available

/**
 * Fetch all available markets
 */
export const getMarkets = async (): Promise<Market[]> => {
  if (USE_MOCK) {
    // Simulate API delay
    await new Promise((r) => setTimeout(r, 500));
    return MOCK_MARKETS;
  }

  const response = await fetch(`${DFLOW_API_BASE}/v1/markets`, {
    headers: {
      'Content-Type': 'application/json',
    },
  });

  if (!response.ok) {
    throw new Error('Failed to fetch markets');
  }

  return response.json();
};

/**
 * Fetch a single market by ID
 */
export const getMarket = async (marketId: string): Promise<Market | null> => {
  if (USE_MOCK) {
    await new Promise((r) => setTimeout(r, 200));
    return MOCK_MARKETS.find((m) => m.id === marketId) || null;
  }

  const response = await fetch(`${DFLOW_API_BASE}/v1/markets/${marketId}`);
  
  if (!response.ok) {
    return null;
  }

  return response.json();
};

/**
 * Fetch markets by category
 */
export const getMarketsByCategory = async (category: string): Promise<Market[]> => {
  const markets = await getMarkets();
  return markets.filter((m) => m.category.toLowerCase() === category.toLowerCase());
};

/**
 * Place an order (mock for now)
 */
export const placeOrder = async (order: OrderRequest): Promise<OrderResponse> => {
  if (USE_MOCK) {
    await new Promise((r) => setTimeout(r, 800));
    
    // Simulate order execution
    return {
      orderId: `order-${Date.now()}`,
      status: 'filled',
      filledQuantity: order.quantity,
      avgFillPrice: order.price || 0.5,
      timestamp: new Date().toISOString(),
    };
  }

  const response = await fetch(`${DFLOW_API_BASE}/v1/orders`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      // 'Authorization': `Bearer ${API_KEY}`, // Add when available
    },
    body: JSON.stringify(order),
  });

  if (!response.ok) {
    throw new Error('Failed to place order');
  }

  return response.json();
};

/**
 * Format price as percentage
 */
export const formatPrice = (price: number): string => {
  return `${(price * 100).toFixed(0)}Â¢`;
};

/**
 * Format volume
 */
export const formatVolume = (volume: number): string => {
  if (volume >= 1_000_000) {
    return `$${(volume / 1_000_000).toFixed(1)}M`;
  }
  if (volume >= 1_000) {
    return `$${(volume / 1_000).toFixed(0)}K`;
  }
  return `$${volume}`;
};


===== C:\Users\burba\tailsharp\src\lib\dflow\copyTradeMarkets.ts =====

// src/lib/dflow/copyTradeMarkets.ts
import { Market, getMarket, placeOrder } from './api';
import { SimulatedTrade } from '@/lib/solana/copyTrade';
import { CopySettings } from '@/types';

export interface MarketCopyTrade extends SimulatedTrade {
  marketId: string;
  marketTitle: string;
  marketTicker: string;
  side: 'yes' | 'no';
  pricePerContract: number;
  contracts: number;
}

/**
 * Generate a copy trade for a market position
 */
export const generateMarketCopyTrade = async (
  traderId: string,
  marketId: string,
  side: 'yes' | 'no',
  traderContracts: number,
  settings: CopySettings
): Promise<MarketCopyTrade | null> => {
  const market = await getMarket(marketId);
  if (!market) return null;

  const price = side === 'yes' ? market.yesPrice : market.noPrice;
  
  // Calculate your position based on allocation
  const traderValue = traderContracts * price;
  const proportion = settings.allocationUsd / 10000; // Assume $10k trader portfolio
  const yourContracts = Math.floor(traderContracts * proportion);
  const yourValue = yourContracts * price;

  // Cap at max position
  const maxPositionValue = settings.allocationUsd * (settings.maxPositionPercent / 100);
  const cappedContracts = yourValue > maxPositionValue 
    ? Math.floor(maxPositionValue / price) 
    : yourContracts;

  if (cappedContracts <= 0) return null;

  const shortAddress = `${traderId.slice(0, 4)}...${traderId.slice(-4)}`;

  return {
    id: `market-${marketId}-${Date.now()}`,
    traderId,
    traderShortAddress: shortAddress,
    tokenMint: marketId,
    tokenSymbol: market.ticker,
    tokenName: market.title,
    action: 'BUY',
    traderAmount: traderContracts,
    yourAmount: cappedContracts,
    yourAllocation: settings.allocationUsd,
    proportionPercent: proportion * 100,
    estimatedCost: cappedContracts * price,
    timestamp: new Date(),
    status: 'pending',
    // Market-specific fields
    marketId,
    marketTitle: market.title,
    marketTicker: market.ticker,
    side,
    pricePerContract: price,
    contracts: cappedContracts,
  };
};

/**
 * Execute a market copy trade
 */
export const executeMarketCopyTrade = async (
  trade: MarketCopyTrade
): Promise<{ success: boolean; orderId?: string; error?: string }> => {
  try {
    const response = await placeOrder({
      marketId: trade.marketId,
      side: trade.side,
      quantity: trade.contracts,
      type: 'market',
    });

    return {
      success: response.status === 'filled',
      orderId: response.orderId,
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
};


===== C:\Users\burba\tailsharp\src\lib\hooks\useAutoRefresh.ts =====

// src/lib/hooks/useAutoRefresh.ts
import { useEffect, useCallback } from 'react';
import { getWalletData, WalletData } from '@/lib/solana/tracker';

interface UseAutoRefreshProps {
  wallets: WalletData[];
  setWallets: React.Dispatch<React.SetStateAction<WalletData[]>>;
  intervalMs?: number;
  enabled?: boolean;
}

export const useAutoRefresh = ({
  wallets,
  setWallets,
  intervalMs = 15000, // 15 seconds default
  enabled = true,
}: UseAutoRefreshProps) => {
  const refreshWallets = useCallback(async () => {
    if (wallets.length === 0) return;

    try {
      const updatedWallets = await Promise.all(
        wallets.map((wallet) => getWalletData(wallet.address))
      );
      setWallets(updatedWallets);
    } catch (error) {
      console.error('Failed to refresh wallets:', error);
    }
  }, [wallets, setWallets]);

  useEffect(() => {
    if (!enabled || wallets.length === 0) return;

    const interval = setInterval(refreshWallets, intervalMs);

    return () => clearInterval(interval);
  }, [enabled, wallets.length, intervalMs, refreshWallets]);

  return { refreshWallets };
};


===== C:\Users\burba\tailsharp\src\lib\hooks\useTradeNotifications.ts =====

import { useEffect, useRef, useCallback } from 'react';
import { useNotifications } from '@/lib/store/useNotifications';

interface ExecutedTrade {
  id: string;
  originalTrade: {
    market: string;
    side: 'YES' | 'NO';
    walletAddress: string;
  };
  status: 'pending' | 'executed' | 'failed';
  error?: string;
  kalshiTicker?: string;
  isSimulation?: boolean;
}

export const useTradeNotifications = (enabled: boolean = true) => {
  const { addNotification } = useNotifications();
  const seenTradeIds = useRef<Set<string>>(new Set());
  const isFirstLoad = useRef(true);

  const checkForNewTrades = useCallback(async () => {
    try {
      const res = await fetch('/api/executed-trades');
      const data = await res.json();
      const trades: ExecutedTrade[] = data.trades || [];

      if (isFirstLoad.current) {
        trades.forEach(t => seenTradeIds.current.add(t.id));
        isFirstLoad.current = false;
        return;
      }

      for (const trade of trades) {
        if (seenTradeIds.current.has(trade.id)) continue;

        seenTradeIds.current.add(trade.id);

        const shortWallet = trade.originalTrade.walletAddress.slice(0, 4) + '...' + trade.originalTrade.walletAddress.slice(-4);
        const simLabel = trade.isSimulation ? ' (Sim)' : '';

        if (trade.status === 'executed') {
          addNotification({
            type: 'trade',
            title: 'Copy Trade Executed' + simLabel,
            message: trade.originalTrade.side + ' ' + (trade.kalshiTicker || trade.originalTrade.market) + ' - ' + shortWallet,
          });
        } else if (trade.status === 'failed') {
          const isNoMatch = trade.error?.includes('No matching');
          addNotification({
            type: isNoMatch ? 'warning' : 'error',
            title: isNoMatch ? 'No Market Match' : 'Trade Failed',
            message: trade.originalTrade.market + ' - ' + (trade.error || 'Unknown error'),
          });
        }
      }
    } catch (error) {
      console.error('[TradeNotifications] Error checking trades:', error);
    }
  }, [addNotification]);

  useEffect(() => {
    if (!enabled) return;

    checkForNewTrades();

    const interval = setInterval(checkForNewTrades, 5000);

    return () => clearInterval(interval);
  }, [enabled, checkForNewTrades]);
};


===== C:\Users\burba\tailsharp\src\lib\hooks\useTransactionWatcher.ts =====

// src/lib/hooks/useTransactionWatcher.ts
import { useEffect, useRef, useCallback } from 'react';
import { getRecentTransactions, Transaction } from '@/lib/solana/transactions';
import { useNotifications } from '@/lib/store/useNotifications';
import { useStore } from '@/lib/store/useStore';

interface WatcherState {
  lastSignatures: Map<string, string>; // walletAddress -> lastSeenSignature
}

export const useTransactionWatcher = (enabled: boolean = true) => {
  const { copySettings } = useStore();
  const { addNotification } = useNotifications();
  const stateRef = useRef<WatcherState>({ lastSignatures: new Map() });

  const activeWallets = copySettings.filter((s) => s.isActive).map((s) => s.traderId);

  const checkForNewTransactions = useCallback(async () => {
    if (activeWallets.length === 0) return;

    for (const walletAddress of activeWallets) {
      try {
        const transactions = await getRecentTransactions(walletAddress, 1);
        
        if (transactions.length === 0) continue;

        const latestTx = transactions[0];
        const lastSeen = stateRef.current.lastSignatures.get(walletAddress);

        // First run - just store the signature
        if (!lastSeen) {
          stateRef.current.lastSignatures.set(walletAddress, latestTx.signature);
          continue;
        }

        // New transaction detected!
        if (latestTx.signature !== lastSeen) {
          stateRef.current.lastSignatures.set(walletAddress, latestTx.signature);

          const shortAddr = `${walletAddress.slice(0, 4)}...${walletAddress.slice(-4)}`;

          addNotification({
            type: 'trade',
            title: 'ðŸ”” New Transaction Detected',
            message: `${shortAddr} just made a move!`,
            walletAddress,
            txSignature: latestTx.signature,
          });
        }
      } catch (error) {
        console.error(`Failed to check transactions for ${walletAddress}:`, error);
      }
    }
  }, [activeWallets, addNotification]);

  useEffect(() => {
    if (!enabled || activeWallets.length === 0) return;

    // Initial check
    checkForNewTransactions();

    // Poll every 10 seconds
    const interval = setInterval(checkForNewTransactions, 10000);

    return () => clearInterval(interval);
  }, [enabled, activeWallets.length, checkForNewTransactions]);

  return { activeWallets: activeWallets.length };
};


===== C:\Users\burba\tailsharp\src\lib\hooks\useWalletData.ts =====

// src/lib/hooks/useWalletData.ts
import { useQuery } from '@tanstack/react-query';
import { getWalletData, WalletData } from '@/lib/solana/tracker';

export const useWalletData = (walletAddress: string | null) => {
  return useQuery<WalletData>({
    queryKey: ['wallet', walletAddress],
    queryFn: () => getWalletData(walletAddress!),
    enabled: !!walletAddress,
    refetchInterval: 30000, // Refresh every 30 seconds
  });
};


===== C:\Users\burba\tailsharp\src\lib\kalshi\client.ts =====

import crypto from 'crypto';

export interface KalshiMarket {
  ticker: string;
  event_ticker: string;
  title: string;
  subtitle?: string;
  status: string;
  yes_bid: number;
  yes_ask: number;
  volume: number;
}

// Convert PKCS#1 to PKCS#8 format for OpenSSL 3.0 compatibility
function convertPKCS1toPKCS8(pkcs1Key: string): string {
  try {
    // Create a key object from the PKCS#1 key
    const keyObject = crypto.createPrivateKey({
      key: pkcs1Key,
      format: 'pem',
      type: 'pkcs1',
    });

    // Export it as PKCS#8
    const pkcs8Key = keyObject.export({
      type: 'pkcs8',
      format: 'pem',
    });

    return pkcs8Key.toString();
  } catch (error) {
    console.error('Error converting key:', error);
    // If conversion fails, return original
    return pkcs1Key;
  }
}

function normalizePrivateKey(rawKey: string): string {
  // Already has proper PEM headers
  if (rawKey.includes('-----BEGIN') && rawKey.includes('-----END')) {
    return rawKey;
  }

  // Decode from base64
  let decoded: string;
  try {
    decoded = Buffer.from(rawKey, 'base64').toString('utf-8');
  } catch (e) {
    decoded = rawKey;
  }

  // Fix literal \n strings to actual newlines (this is the key fix!)
  if (decoded.includes('\\n')) {
    decoded = decoded.replace(/\\n/g, '\n');
  }

  return decoded;
}

export class KalshiClient {
  private privateKey: string;
  private apiKeyId: string;
  private baseUrl: string;

  constructor(apiKeyId: string, privateKey: string, isDemo = true) {
    this.apiKeyId = apiKeyId;

    const normalizedKey = normalizePrivateKey(privateKey);
    
    // Convert PKCS#1 to PKCS#8 for Vercel OpenSSL 3.0 compatibility
    this.privateKey = convertPKCS1toPKCS8(normalizedKey);

    this.baseUrl = isDemo
      ? 'https://demo-api.kalshi.co'
      : 'https://api.kalshi.com';
  }

  private signRequest(timestamp: string, method: string, path: string): string {
    const pathWithoutQuery = path.split('?')[0];
    const message = `${timestamp}${method}${pathWithoutQuery}`;

    const sign = crypto.createSign('RSA-SHA256');
    sign.update(message);
    sign.end();

    const signature = sign.sign(
      {
        key: this.privateKey,
        format: 'pem',
        type: 'pkcs8',
        padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST,
      },
      'base64'
    );

    return signature;
  }

  private getHeaders(method: string, path: string) {
    const timestamp = Date.now().toString();
    const signature = this.signRequest(timestamp, method, path);

    return {
      'KALSHI-ACCESS-KEY': this.apiKeyId,
      'KALSHI-ACCESS-TIMESTAMP': timestamp,
      'KALSHI-ACCESS-SIGNATURE': signature,
    };
  }

  async getBalance() {
    const path = '/trade-api/v2/portfolio/balance';
    const headers = this.getHeaders('GET', path);

    const response = await fetch(this.baseUrl + path, { headers });
    return response.json();
  }

  async searchMarkets(params?: {
    status?: 'open' | 'closed' | 'settled';
    limit?: number;
    series_ticker?: string;
  }): Promise<KalshiMarket[]> {
    const queryParams = new URLSearchParams();
    if (params?.status) queryParams.append('status', params.status);
    if (params?.limit) queryParams.append('limit', params.limit.toString());
    if (params?.series_ticker) queryParams.append('series_ticker', params.series_ticker);

    const queryString = queryParams.toString();
    const path = `/trade-api/v2/markets${queryString ? '?' + queryString : ''}`;
    const headers = this.getHeaders('GET', path);

    const response = await fetch(this.baseUrl + path, { headers });
    const data = await response.json();

    return data.markets || [];
  }

  async getMarket(ticker: string): Promise<KalshiMarket | null> {
    const path = `/trade-api/v2/markets/${ticker}`;
    const headers = this.getHeaders('GET', path);

    const response = await fetch(this.baseUrl + path, { headers });
    const data = await response.json();

    return data.market || null;
  }

  async createOrder(
    ticker: string,
    action: 'buy' | 'sell',
    count: number,
    side: 'yes' | 'no'
  ) {
    const path = '/trade-api/v2/portfolio/orders';
    const headers = this.getHeaders('POST', path);

    const body = {
      ticker,
      action,
      count,
      side,
      type: 'market',
    };

    const response = await fetch(this.baseUrl + path, {
      method: 'POST',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify(body),
    });

    return response.json();
  }
}


===== C:\Users\burba\tailsharp\src\lib\kalshi\marketMatcher.ts =====

import { KalshiClient, KalshiMarket } from './client';

let marketCache: KalshiMarket[] = [];
let cacheTimestamp = 0;
const CACHE_DURATION = 1 * 60 * 1000;

type MarketCategory =
  | 'election_outcome'
  | 'legal'
  | 'policy_action'
  | 'event'
  | 'numeric'
  | 'unknown';

function detectCategory(text: string): MarketCategory {
  const lower = text.toLowerCase();

  const legalPatterns = [
    /\b(lawsuit|lawsuits|sue|sued|suing)\b/,
    /\b(court|courts|judge|judges|ruling|verdict)\b/,
    /\b(trial|trials|prosecute|prosecution|prosecutor)\b/,
    /\b(convicted|conviction|acquit|acquitted|guilty|innocent)\b/,
    /\b(indicted|indictment|charged|charges)\b/,
    /\b(settlement|settle|appeal|appeals)\b/,
    /\b(supreme court|circuit court|district court)\b/,
    /\bjustice\s+(department|system)\b/,
    /\bwin\s+(his|her|the|their)\s+(lawsuit|case|trial|appeal)\b/,
  ];

  for (const pattern of legalPatterns) {
    if (pattern.test(lower)) {
      return 'legal';
    }
  }

  const electionPatterns = [
    /\b(wins?|won|winning)\s+(the\s+)?(election|race|primary|caucus|presidency)\b/,
    /\b(election|race|primary|caucus)\b.*\b(wins?|won|winning)\b/,
    /\b(elected|reelected)\s+(as\s+)?(president|senator|governor|mayor|representative)\b/,
    /\bwho\s+(wins?|will win)\s+(the\s+)?(election|race|presidency)\b/,
    /\b(president|senator|governor|mayor|representative)\s+(election|race)\b/,
    /\bwin\s+(the\s+)?(2024|2025|2026|2028)\s+(election|race|presidency)\b/,
    /\b(2024|2025|2026|2028)\s+(election|race|presidential)\b/,
    /\bpresidential\s+(election|race|winner|candidate)\b/,
    /\b(democrat|republican|gop|dnc|rnc)\s+(wins?|nominee|candidate)\b/,
    /\belectoral\s+(college|vote|votes)\b/,
    /\bwin\s+the\s+white\s+house\b/,
  ];

  for (const pattern of electionPatterns) {
    if (pattern.test(lower)) {
      return 'election_outcome';
    }
  }

  const policyPatterns = [
    /\bwill\s+\w+\s+(sign|veto|pass|approve|reject|reduce|increase|implement|announce|ban|allow)\b/,
    /\b(sign|veto|pass|approve|reject)\s+(a\s+)?(bill|law|legislation|order)\b/,
    /\b(tariff|tax|rate|policy|legislation)\b/,
    /\breduce\s+(inequality|debt|deficit|spending)\b/,
    /\bincrease\s+(spending|taxes|tariffs)\b/,
    /\bexecutive\s+order\b/,
  ];

  for (const pattern of policyPatterns) {
    if (pattern.test(lower)) {
      return 'policy_action';
    }
  }

  const numericPatterns = [
    /\b(above|below|over|under|exceed|reach)\s+\d/,
    /\b\d+(\.\d+)?%/,
    /\b(price|rate|index|gdp|inflation)\b.*\b\d/,
  ];

  for (const pattern of numericPatterns) {
    if (pattern.test(lower)) {
      return 'numeric';
    }
  }

  const eventPatterns = [
    /\bwill\s+.+\s+before\b/,
    /\bby\s+(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|\d{4})\b/i,
    /\bwill\s+.+\s+(happen|occur|take place|visit|travel|go to)\b/,
  ];

  for (const pattern of eventPatterns) {
    if (pattern.test(lower)) {
      return 'event';
    }
  }

  return 'unknown';
}

function extractEntities(text: string): { people: string[]; years: string[]; keywords: string[] } {
  const lower = text.toLowerCase();

  const knownPeople = [
    'trump', 'biden', 'harris', 'desantis', 'newsom', 'pence', 'obama',
    'clinton', 'sanders', 'warren', 'buttigieg', 'haley', 'ramaswamy',
    'scott', 'christie', 'burgum', 'hutchinson', 'elder', 'lake',
    'vance', 'walz', 'pelosi', 'schumer', 'mcconnell', 'musk', 'elon'
  ];

  const people = knownPeople.filter(person => lower.includes(person));

  const yearMatches = lower.match(/\b(202\d|203\d)\b/g) || [];
  const years = [...new Set(yearMatches)];

  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
    'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could',
    'should', 'may', 'might', 'must', 'shall', 'can', 'this', 'that',
    'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they',
    'his', 'her', 'its', 'their', 'our', 'your', 'who', 'what', 'when',
    'where', 'why', 'how', 'which', 'there', 'here', 'all', 'each',
    'every', 'both', 'few', 'more', 'most', 'other', 'some', 'such',
    'only', 'own', 'same', 'so', 'than', 'too', 'very', 'just', 'also'
  ]);

  const words = lower.replace(/[^a-z0-9\s]/g, ' ').split(/\s+/).filter(w => w.length > 2);
  const keywords = words.filter(w => !stopWords.has(w) && !knownPeople.includes(w));

  return { people, years, keywords };
}

async function getOpenMarkets(client: KalshiClient): Promise<KalshiMarket[]> {
  const now = Date.now();

  if (marketCache.length > 0 && now - cacheTimestamp < CACHE_DURATION) {
    console.log('[MarketMatcher] Using cached markets:', marketCache.length);
    return marketCache;
  }

  console.log('[MarketMatcher] Fetching fresh market data from Kalshi...');
  try {
    marketCache = await client.searchMarkets({ status: 'open', limit: 1000 });
    cacheTimestamp = now;
    console.log('[MarketMatcher] Fetched', marketCache.length, 'markets from Kalshi');
  } catch (error) {
    console.error('[MarketMatcher] Failed to fetch markets from Kalshi:', error);
    marketCache = [];
  }

  return marketCache;
}

export async function findMatchingTicker(
  client: KalshiClient,
  marketDescription: string
): Promise<string | null> {
  try {
    const markets = await getOpenMarkets(client);

    if (markets.length === 0) {
      console.warn('[MarketMatcher] No open markets found on Kalshi');
      return null;
    }

    const sourceCategory = detectCategory(marketDescription);
    const sourceEntities = extractEntities(marketDescription);

    console.log('[MarketMatcher] Source:', marketDescription);
    console.log('[MarketMatcher] Category:', sourceCategory);
    console.log('[MarketMatcher] Entities:', sourceEntities);

    const scoredMarkets = markets.map(market => {
      const marketText = (market.title + ' ' + (market.subtitle || '') + ' ' + market.ticker).toLowerCase();
      const marketCategory = detectCategory(marketText);
      const marketEntities = extractEntities(marketText);

      let score = 0;
      const matchReasons: string[] = [];

      // Check if source has people and if market matches them
      const sourcePeopleCount = sourceEntities.people.length;
      let matchedPeopleCount = 0;

      for (const person of sourceEntities.people) {
        if (marketEntities.people.includes(person)) {
          matchedPeopleCount++;
          score += 30;
          matchReasons.push('person:' + person);
        }
      }

      // CRITICAL: If source mentions specific people, market MUST include at least one
      // Otherwise apply heavy penalty
      if (sourcePeopleCount > 0 && matchedPeopleCount === 0) {
        score -= 200;
        matchReasons.push('missing_person_penalty');
      }

      // Category matching
      const categoryMatch = sourceCategory === marketCategory ||
                           sourceCategory === 'unknown' ||
                           marketCategory === 'unknown';

      if (sourceCategory !== 'unknown' && marketCategory !== 'unknown') {
        if (categoryMatch) {
          score += 50;
          matchReasons.push('category:' + sourceCategory);
        } else {
          score -= 100;
          matchReasons.push('category_mismatch:' + sourceCategory + '!=' + marketCategory);
        }
      }

      // Year matches
      for (const year of sourceEntities.years) {
        if (marketEntities.years.includes(year)) {
          score += 20;
          matchReasons.push('year:' + year);
        }
      }

      // Keyword matches
      for (const keyword of sourceEntities.keywords) {
        if (marketText.includes(keyword)) {
          score += 3;
          matchReasons.push('keyword:' + keyword);
        }
      }

      // Exact phrase match bonus
      const normalizedSource = marketDescription.toLowerCase().replace(/[^a-z0-9\s]/g, '').trim();
      if (marketText.includes(normalizedSource)) {
        score += 100;
        matchReasons.push('exact_phrase');
      }

      return {
        market,
        score,
        category: marketCategory,
        matchReasons
      };
    });

    scoredMarkets.sort((a, b) => b.score - a.score);

    console.log('[MarketMatcher] Top 5 candidates:');
    scoredMarkets.slice(0, 5).forEach((m, i) => {
      console.log('  ' + (i + 1) + '. [' + m.score + '] ' + m.market.ticker + ' - "' + m.market.title + '" (' + m.category + ') [' + m.matchReasons.join(', ') + ']');
    });

    const bestMatch = scoredMarkets[0];

    // Require minimum score threshold
    if (bestMatch.score < 50) {
      console.warn('[MarketMatcher] No good match found for:', marketDescription, '(best score:', bestMatch.score + ')');
      return null;
    }

    console.log('[MarketMatcher] Selected:', bestMatch.market.ticker, '-', bestMatch.market.title, '(score:', bestMatch.score + ')');
    return bestMatch.market.ticker;

  } catch (error) {
    console.error('[MarketMatcher] Error finding matching ticker:', error);
    return null;
  }
}

export function clearMarketCache() {
  marketCache = [];
  cacheTimestamp = 0;
}


===== C:\Users\burba\tailsharp\src\lib\solana\connection.ts =====

// src/lib/solana/connection.ts
import { Connection, clusterApiUrl } from '@solana/web3.js';

const RPC_URL = process.env.NEXT_PUBLIC_SOLANA_RPC_URL || clusterApiUrl('mainnet-beta');

// Singleton connection instance
let connection: Connection | null = null;

export const getConnection = (): Connection => {
  if (!connection) {
    connection = new Connection(RPC_URL, {
      commitment: 'confirmed',
      confirmTransactionInitialTimeout: 60000,
    });
  }
  return connection;
};

export const LAMPORTS_PER_SOL = 1_000_000_000;

export const formatSol = (lamports: number): string => {
  return (lamports / LAMPORTS_PER_SOL).toFixed(4);
};


===== C:\Users\burba\tailsharp\src\lib\solana\copyTrade.ts =====

// src/lib/solana/copyTrade.ts
import { CopySettings } from '@/types';
import { TokenBalance } from './tracker';
import { getTokenInfo } from './tokens';

export interface SimulatedTrade {
  id: string;
  traderId: string;
  traderShortAddress: string;
  tokenMint: string;
  tokenSymbol: string;
  tokenName: string;
  action: 'BUY' | 'SELL';
  traderAmount: number;
  yourAmount: number;
  yourAllocation: number;
  proportionPercent: number;
  estimatedCost: number;
  timestamp: Date;
  status: 'pending' | 'ready' | 'executed' | 'failed';
}

export interface PositionDiff {
  mint: string;
  symbol: string;
  name: string;
  previousAmount: number;
  currentAmount: number;
  change: number;
  changePercent: number;
  action: 'BUY' | 'SELL' | 'HOLD';
}

/**
 * Calculate position differences between two snapshots
 */
export const calculatePositionDiff = (
  previousTokens: TokenBalance[],
  currentTokens: TokenBalance[]
): PositionDiff[] => {
  const diffs: PositionDiff[] = [];
  const previousMap = new Map(previousTokens.map((t) => [t.mint, t.uiAmount]));
  const currentMap = new Map(currentTokens.map((t) => [t.mint, t.uiAmount]));

  // Check all current tokens
  currentTokens.forEach((token) => {
    const previous = previousMap.get(token.mint) || 0;
    const current = token.uiAmount;
    const change = current - previous;

    if (Math.abs(change) > 0.0001) {
      const info = getTokenInfo(token.mint);
      diffs.push({
        mint: token.mint,
        symbol: info.symbol,
        name: info.name,
        previousAmount: previous,
        currentAmount: current,
        change,
        changePercent: previous > 0 ? (change / previous) * 100 : 100,
        action: change > 0 ? 'BUY' : 'SELL',
      });
    }
  });

  // Check for tokens that were sold completely (in previous but not in current)
  previousTokens.forEach((token) => {
    if (!currentMap.has(token.mint) || currentMap.get(token.mint) === 0) {
      const info = getTokenInfo(token.mint);
      diffs.push({
        mint: token.mint,
        symbol: info.symbol,
        name: info.name,
        previousAmount: token.uiAmount,
        currentAmount: 0,
        change: -token.uiAmount,
        changePercent: -100,
        action: 'SELL',
      });
    }
  });

  return diffs;
};

/**
 * Calculate simulated copy trade based on settings
 */
export const calculateCopyTrade = (
  diff: PositionDiff,
  settings: CopySettings,
  traderTotalValue: number = 10000 // Estimated trader portfolio value
): SimulatedTrade => {
  // Calculate proportion: your allocation / trader's estimated portfolio
  const proportion = settings.allocationUsd / traderTotalValue;

  // Your mirrored amount
  const yourAmount = Math.abs(diff.change) * proportion;

  // Cap at max position percent
  const maxPosition = settings.allocationUsd * (settings.maxPositionPercent / 100);
  const cappedAmount = Math.min(yourAmount, maxPosition);

  // Estimate cost (simplified - would need price feeds for accuracy)
  const estimatedCost = cappedAmount; // Assuming 1:1 for now

  const shortAddress = `${settings.traderId.slice(0, 4)}...${settings.traderId.slice(-4)}`;

  return {
    id: `${settings.traderId}-${diff.mint}-${Date.now()}`,
    traderId: settings.traderId,
    traderShortAddress: shortAddress,
    tokenMint: diff.mint,
    tokenSymbol: diff.symbol,
    tokenName: diff.name,
    action: diff.action as 'BUY' | 'SELL',
    traderAmount: Math.abs(diff.change),
    yourAmount: cappedAmount,
    yourAllocation: settings.allocationUsd,
    proportionPercent: proportion * 100,
    estimatedCost,
    timestamp: new Date(),
    status: 'pending',
  };
};

/**
 * Validate if a trade should be executed based on settings
 */
export const shouldExecuteTrade = (
  trade: SimulatedTrade,
  settings: CopySettings
): { valid: boolean; reason?: string } => {
  if (!settings.isActive) {
    return { valid: false, reason: 'Copy trading is paused for this trader' };
  }

  if (trade.estimatedCost > settings.allocationUsd) {
    return { valid: false, reason: 'Trade exceeds allocation' };
  }

  const maxPositionValue = settings.allocationUsd * (settings.maxPositionPercent / 100);
  if (trade.estimatedCost > maxPositionValue) {
    return { valid: false, reason: 'Trade exceeds max position size' };
  }

  return { valid: true };
};

/**
 * Format currency for display
 */
export const formatUsd = (amount: number): string => {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 2,
    maximumFractionDigits: 2,
  }).format(amount);
};


===== C:\Users\burba\tailsharp\src\lib\solana\tokens.ts =====

// src/lib/solana/tokens.ts

// Known token registry (we'll expand this)
// In production, you'd use Helius DAS API or Jupiter token list
const KNOWN_TOKENS: Record<string, { symbol: string; name: string; decimals: number }> = {
  'So11111111111111111111111111111111111111112': {
    symbol: 'SOL',
    name: 'Wrapped SOL',
    decimals: 9,
  },
  'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': {
    symbol: 'USDC',
    name: 'USD Coin',
    decimals: 6,
  },
  'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': {
    symbol: 'USDT',
    name: 'Tether USD',
    decimals: 6,
  },
  'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': {
    symbol: 'BONK',
    name: 'Bonk',
    decimals: 5,
  },
  'JUPyiwrYJFskUPiHa7hkeR8VUtAeFoSYbKedZNsDvCN': {
    symbol: 'JUP',
    name: 'Jupiter',
    decimals: 6,
  },
  'mSoLzYCxHdYgdzU16g5QSh3i5K3z3KZK7ytfqcJm7So': {
    symbol: 'mSOL',
    name: 'Marinade Staked SOL',
    decimals: 9,
  },
  'HZ1JovNiVvGrGNiiYvEozEVgZ58xaU3RKwX8eACQBCt3': {
    symbol: 'PYTH',
    name: 'Pyth Network',
    decimals: 6,
  },
  'rndrizKT3MK1iimdxRdWabcF7Zg7AR5T4nud4EkHBof': {
    symbol: 'RENDER',
    name: 'Render Token',
    decimals: 8,
  },
};

export interface TokenInfo {
  mint: string;
  symbol: string;
  name: string;
  decimals: number;
  isKnown: boolean;
}

export const getTokenInfo = (mint: string): TokenInfo => {
  const known = KNOWN_TOKENS[mint];
  
  if (known) {
    return {
      mint,
      symbol: known.symbol,
      name: known.name,
      decimals: known.decimals,
      isKnown: true,
    };
  }

  // Unknown token - return truncated mint as symbol
  return {
    mint,
    symbol: `${mint.slice(0, 4)}...`,
    name: 'Unknown Token',
    decimals: 0,
    isKnown: false,
  };
};

export const formatTokenAmount = (amount: number, decimals: number): string => {
  if (amount === 0) return '0';
  
  if (amount >= 1_000_000) {
    return `${(amount / 1_000_000).toFixed(2)}M`;
  }
  if (amount >= 1_000) {
    return `${(amount / 1_000).toFixed(2)}K`;
  }
  
  return amount.toLocaleString(undefined, { maximumFractionDigits: 4 });
};


===== C:\Users\burba\tailsharp\src\lib\solana\tracker.ts =====

// src/lib/solana/tracker.ts
import { PublicKey } from '@solana/web3.js';
import { TOKEN_PROGRAM_ID } from '@solana/spl-token';
import { getConnection } from './connection';

export interface TokenBalance {
  mint: string;
  amount: number;
  decimals: number;
  uiAmount: number;
}

export interface WalletData {
  address: string;
  solBalance: number;
  tokens: TokenBalance[];
  lastUpdated: Date;
}

/**
 * Fetch SOL balance for a wallet
 */
export const getSolBalance = async (walletAddress: string): Promise<number> => {
  const connection = getConnection();
  const pubkey = new PublicKey(walletAddress);
  const balance = await connection.getBalance(pubkey);
  return balance;
};

/**
 * Fetch all SPL token balances for a wallet
 * This includes Kalshi prediction market positions (they're SPL tokens on Solana)
 */
export const getTokenBalances = async (walletAddress: string): Promise<TokenBalance[]> => {
  const connection = getConnection();
  const pubkey = new PublicKey(walletAddress);

  const tokenAccounts = await connection.getParsedTokenAccountsByOwner(pubkey, {
    programId: TOKEN_PROGRAM_ID,
  });

  return tokenAccounts.value
    .map((account) => {
      const parsed = account.account.data.parsed.info;
      return {
        mint: parsed.mint,
        amount: Number(parsed.tokenAmount.amount),
        decimals: parsed.tokenAmount.decimals,
        uiAmount: parsed.tokenAmount.uiAmount || 0,
      };
    })
    .filter((token) => token.uiAmount > 0); // Only tokens with balance
};

/**
 * Get full wallet data including SOL and all tokens
 */
export const getWalletData = async (walletAddress: string): Promise<WalletData> => {
  const [solBalance, tokens] = await Promise.all([
    getSolBalance(walletAddress),
    getTokenBalances(walletAddress),
  ]);

  return {
    address: walletAddress,
    solBalance,
    tokens,
    lastUpdated: new Date(),
  };
};

/**
 * Validate if a string is a valid Solana address
 */
export const isValidSolanaAddress = (address: string): boolean => {
  try {
    new PublicKey(address);
    return true;
  } catch {
    return false;
  }
};


===== C:\Users\burba\tailsharp\src\lib\solana\transactions.ts =====

// src/lib/solana/transactions.ts
import { PublicKey } from '@solana/web3.js';
import { getConnection } from './connection';

export interface Transaction {
  signature: string;
  slot: number;
  timestamp: number | null;
  success: boolean;
  fee: number;
  type: 'unknown' | 'transfer' | 'swap' | 'stake' | 'other';
  description?: string;
}

export interface TransactionDetail {
  signature: string;
  timestamp: number | null;
  success: boolean;
  fee: number;
  instructions: string[];
  balanceChanges: BalanceChange[];
}

export interface BalanceChange {
  mint: string;
  amount: number;
  direction: 'in' | 'out';
}

/**
 * Get recent transaction signatures for a wallet (from RPC)
 */
export const getRecentTransactions = async (
  walletAddress: string,
  limit: number = 10
): Promise<Transaction[]> => {
  const connection = getConnection();
  const pubkey = new PublicKey(walletAddress);

  const signatures = await connection.getSignaturesForAddress(pubkey, { limit });

  return signatures.map((sig) => ({
    signature: sig.signature,
    slot: sig.slot,
    timestamp: sig.blockTime ?? null,
    success: sig.err === null,
    fee: 0,
    type: 'unknown' as const,
  }));
};

/**
 * Get transactions from webhook cache (real-time tracked data)
 */
export const getWebhookTransactions = async (
  walletAddress: string
): Promise<Transaction[]> => {
  try {
    const response = await fetch(`/api/webhook?wallet=${walletAddress}`);
    if (!response.ok) return [];
    
    const data = await response.json();
    
    return data.transactions.map((tx: any) => ({
      signature: tx.signature,
      slot: 0,
      timestamp: tx.timestamp ?? null,
      success: true,
      fee: tx.fee || 0,
      type: mapTransactionType(tx.type),
      description: tx.description,
    }));
  } catch (error) {
    console.error('Failed to fetch webhook transactions:', error);
    return [];
  }
};

const mapTransactionType = (heliusType: string): Transaction['type'] => {
  const typeMap: Record<string, Transaction['type']> = {
    'TRANSFER': 'transfer',
    'SWAP': 'swap',
    'STAKE': 'stake',
  };
  return typeMap[heliusType] || 'other';
};

/**
 * Get combined transactions (webhook + RPC fallback)
 */
export const getCombinedTransactions = async (
  walletAddress: string,
  limit: number = 10
): Promise<Transaction[]> => {
  const [webhookTxs, rpcTxs] = await Promise.all([
    getWebhookTransactions(walletAddress),
    getRecentTransactions(walletAddress, limit),
  ]);

  const txMap = new Map<string, Transaction>();
  
  rpcTxs.forEach(tx => txMap.set(tx.signature, tx));
  webhookTxs.forEach(tx => txMap.set(tx.signature, tx));
  
  return Array.from(txMap.values())
    .sort((a, b) => (b.timestamp ?? 0) - (a.timestamp ?? 0))
    .slice(0, limit);
};

/**
 * Get transaction details
 */
export const getTransactionDetail = async (
  signature: string
): Promise<TransactionDetail | null> => {
  const connection = getConnection();

  try {
    const tx = await connection.getParsedTransaction(signature, {
      maxSupportedTransactionVersion: 0,
    });

    if (!tx) return null;

    const instructions = tx.transaction.message.instructions.map((ix) => {
      if ('program' in ix) {
        return ix.program;
      }
      if ('programId' in ix) {
        return ix.programId.toString();
      }
      return 'unknown';
    });

    const balanceChanges: BalanceChange[] = [];

    if (tx.meta?.preTokenBalances && tx.meta?.postTokenBalances) {
      const preBalances = new Map(
        tx.meta.preTokenBalances.map((b) => [
          `${b.accountIndex}-${b.mint}`,
          b.uiTokenAmount.uiAmount || 0,
        ])
      );

      tx.meta.postTokenBalances.forEach((post) => {
        const key = `${post.accountIndex}-${post.mint}`;
        const pre = preBalances.get(key) || 0;
        const postAmount = post.uiTokenAmount.uiAmount || 0;
        const diff = postAmount - pre;

        if (diff !== 0) {
          balanceChanges.push({
            mint: post.mint,
            amount: Math.abs(diff),
            direction: diff > 0 ? 'in' : 'out',
          });
        }
      });
    }

    return {
      signature,
      timestamp: tx.blockTime ?? null,
      success: tx.meta?.err === null,
      fee: tx.meta?.fee || 0,
      instructions,
      balanceChanges,
    };
  } catch (error) {
    console.error('Failed to fetch transaction:', error);
    return null;
  }
};

/**
 * Format timestamp to relative time
 */
export const formatTimeAgo = (timestamp: number | null): string => {
  if (!timestamp) return 'Unknown';

  const now = Math.floor(Date.now() / 1000);
  const diff = now - timestamp;

  if (diff < 60) return `${diff}s ago`;
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
  return `${Math.floor(diff / 86400)}d ago`;
};

/**
 * Shorten signature for display
 */
export const shortenSignature = (sig: string): string => {
  return `${sig.slice(0, 8)}...${sig.slice(-8)}`;
};


===== C:\Users\burba\tailsharp\src\lib\store\useCopyTrades.ts =====

// src/lib/store/useCopyTrades.ts
import { create } from 'zustand';
import { SimulatedTrade } from '@/lib/solana/copyTrade';

interface CopyTradeState {
  simulatedTrades: SimulatedTrade[];
  executedTrades: SimulatedTrade[];
  
  addSimulatedTrade: (trade: SimulatedTrade) => void;
  removeSimulatedTrade: (id: string) => void;
  clearSimulatedTrades: () => void;
  
  executeTrade: (id: string) => void;
  rejectTrade: (id: string) => void;
  
  getTradesByTrader: (traderId: string) => SimulatedTrade[];
  getPendingCount: () => number;
}

export const useCopyTrades = create<CopyTradeState>((set, get) => ({
  simulatedTrades: [],
  executedTrades: [],

  addSimulatedTrade: (trade) =>
    set((state) => ({
      simulatedTrades: [trade, ...state.simulatedTrades].slice(0, 100), // Keep last 100
    })),

  removeSimulatedTrade: (id) =>
    set((state) => ({
      simulatedTrades: state.simulatedTrades.filter((t) => t.id !== id),
    })),

  clearSimulatedTrades: () =>
    set({ simulatedTrades: [] }),

  executeTrade: (id) =>
    set((state) => {
      const trade = state.simulatedTrades.find((t) => t.id === id);
      if (!trade) return state;

      return {
        simulatedTrades: state.simulatedTrades.filter((t) => t.id !== id),
        executedTrades: [
          { ...trade, status: 'executed' as const, timestamp: new Date() },
          ...state.executedTrades,
        ].slice(0, 100),
      };
    }),

  rejectTrade: (id) =>
    set((state) => ({
      simulatedTrades: state.simulatedTrades.filter((t) => t.id !== id),
    })),

  getTradesByTrader: (traderId) => {
    return get().simulatedTrades.filter((t) => t.traderId === traderId);
  },

  getPendingCount: () => {
    return get().simulatedTrades.filter((t) => t.status === 'pending').length;
  },
}));


===== C:\Users\burba\tailsharp\src\lib\store\useNotifications.ts =====

// src/lib/store/useNotifications.ts
import { create } from 'zustand';

export interface Notification {
  id: string;
  type: 'trade' | 'info' | 'warning' | 'error';
  title: string;
  message: string;
  walletAddress?: string;
  txSignature?: string;
  timestamp: Date;
  read: boolean;
}

interface NotificationState {
  notifications: Notification[];
  unreadCount: number;
  addNotification: (notification: Omit<Notification, 'id' | 'timestamp' | 'read'>) => void;
  markAsRead: (id: string) => void;
  markAllAsRead: () => void;
  clearAll: () => void;
}

export const useNotifications = create<NotificationState>((set) => ({
  notifications: [],
  unreadCount: 0,

  addNotification: (notification) =>
    set((state) => {
      const newNotification: Notification = {
        ...notification,
        id: `${Date.now()}-${Math.random().toString(36).slice(2)}`,
        timestamp: new Date(),
        read: false,
      };
      return {
        notifications: [newNotification, ...state.notifications].slice(0, 50), // Keep last 50
        unreadCount: state.unreadCount + 1,
      };
    }),

  markAsRead: (id) =>
    set((state) => ({
      notifications: state.notifications.map((n) =>
        n.id === id ? { ...n, read: true } : n
      ),
      unreadCount: Math.max(0, state.unreadCount - 1),
    })),

  markAllAsRead: () =>
    set((state) => ({
      notifications: state.notifications.map((n) => ({ ...n, read: true })),
      unreadCount: 0,
    })),

  clearAll: () =>
    set({
      notifications: [],
      unreadCount: 0,
    }),
}));


===== C:\Users\burba\tailsharp\src\lib\store\useStore.ts =====

// src/lib/store/useStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Trader, CopySettings } from '@/types';

interface AppState {
  // Tracked traders (the "sharps" we're watching)
  trackedTraders: Trader[];
  addTrader: (trader: Trader) => void;
  removeTrader: (address: string) => void;
  updateTrader: (address: string, data: Partial<Trader>) => void;

  // User's copy settings
  copySettings: CopySettings[];
  addCopySettings: (settings: CopySettings) => Promise<void>;
  removeCopySettings: (traderId: string) => void;
  updateCopySettings: (traderId: string, data: Partial<CopySettings>) => void;

  // Webhook IDs (to track registered webhooks)
  webhookIds: Record<string, string>;

  // UI State
  isLoading: boolean;
  setIsLoading: (loading: boolean) => void;
}

export const useStore = create<AppState>()(
  persist(
    (set, get) => ({
      // Traders
      trackedTraders: [],
      addTrader: (trader) =>
        set((state) => ({
          trackedTraders: [...state.trackedTraders, trader],
        })),
      removeTrader: (address) =>
        set((state) => ({
          trackedTraders: state.trackedTraders.filter((t) => t.address !== address),
        })),
      updateTrader: (address, data) =>
        set((state) => ({
          trackedTraders: state.trackedTraders.map((t) =>
            t.address === address ? { ...t, ...data } : t
          ),
        })),

      // Copy Settings - now registers webhook with Helius
      copySettings: [],
      addCopySettings: async (settings) => {
        // Add to local state first
        set((state) => ({
          copySettings: [...state.copySettings, settings],
        }));

        // Register webhook with Helius
        try {
          const response = await fetch('/api/webhook/register', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ walletAddress: settings.traderId }),
          });

          if (response.ok) {
            const data = await response.json();
            console.log('Webhook registered:', data);
            
            // Store webhook ID
            if (data.webhookId) {
              set((state) => ({
                webhookIds: { ...state.webhookIds, [settings.traderId]: data.webhookId },
              }));
            }
                  } else {
            const errorData = await response.text();
            console.error('Failed to register webhook:', response.status, errorData);
          } 
        } catch (error) {
          console.error('Webhook registration error:', error);
        }
      },
      removeCopySettings: (traderId) =>
        set((state) => ({
          copySettings: state.copySettings.filter((s) => s.traderId !== traderId),
        })),
      updateCopySettings: (traderId, data) =>
        set((state) => ({
          copySettings: state.copySettings.map((s) =>
            s.traderId === traderId ? { ...s, ...data } : s
          ),
        })),

      // Webhook tracking
      webhookIds: {},

      // UI
      isLoading: false,
      setIsLoading: (loading) => set({ isLoading: loading }),
    }),
    {
      name: 'tailsharp-storage',
    }
  )
);


===== C:\Users\burba\tailsharp\src\lib\trading\copyEngine.ts =====

// src/lib/trading/copyEngine.ts
import { ParsedTrade } from './transactionParser';

export interface CopySettings {
  traderId: string;
  isActive: boolean;
  allocationUsd: number;
  maxPositionPercent: number;
}

export interface CopyDecision {
  shouldCopy: boolean;
  reason?: string;
  positionSize?: number;
  settings?: CopySettings;
}

/**
 * Decide if we should copy a trade based on user settings
 */
export function shouldCopyTrade(
  trade: ParsedTrade,
  settings: CopySettings[]
): CopyDecision {
  // Find settings for this trader
  const traderSettings = settings.find(s => s.traderId === trade.walletAddress);

  if (!traderSettings) {
    return {
      shouldCopy: false,
      reason: 'Trader not followed',
    };
  }

  if (!traderSettings.isActive) {
    return {
      shouldCopy: false,
      reason: 'Auto-copy is paused for this trader',
    };
  }

  // Calculate position size
  const positionSize = calculatePositionSize(trade, traderSettings);

  if (positionSize <= 0) {
    return {
      shouldCopy: false,
      reason: 'Position size too small',
    };
  }

  return {
    shouldCopy: true,
    positionSize,
    settings: traderSettings,
  };
}

/**
 * Calculate how much to trade based on user's allocation settings
 */
function calculatePositionSize(
  trade: ParsedTrade,
  settings: CopySettings
): number {
  // Max position is a percentage of total allocation
  const maxPosition = settings.allocationUsd * (settings.maxPositionPercent / 100);

  // Scale the trade amount proportionally
  // For now, use a simple 1:1 ratio up to max position
  const scaledAmount = Math.min(trade.amount, maxPosition);

  return scaledAmount;
}

/**
 * Check if we have enough balance to execute the trade
 */
export function hasEnoughBalance(
  positionSize: number,
  availableBalance: number
): boolean {
  return availableBalance >= positionSize;
}


===== C:\Users\burba\tailsharp\src\lib\trading\tradeExecutor.ts =====

import { ParsedTrade } from './transactionParser';
import { CopyDecision } from './copyEngine';
import { KalshiClient } from '../kalshi/client';
import { findMatchingTicker } from '../kalshi/marketMatcher';
import { IS_SIMULATION_SERVER } from '../env';

export interface ExecutedTrade {
  id: string;
  originalTrade: ParsedTrade;
  decision: CopyDecision;
  status: 'pending' | 'executed' | 'failed';
  executedAt?: number;
  error?: string;
  ourOrderId?: string;
  kalshiTicker?: string;
  kalshiResponse?: any;
  isSimulation?: boolean;
}

export async function executeCopyTrade(
  trade: ParsedTrade,
  decision: CopyDecision
): Promise<ExecutedTrade> {
  const tradeId = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
  const isSimulation = IS_SIMULATION_SERVER;

  try {
    console.log('[TradeExecutor] Executing copy trade:', {
      market: trade.market,
      side: trade.side,
      amount: decision.positionSize,
      originalTrader: trade.walletAddress,
      simulation: isSimulation,
    });

    const client = new KalshiClient(
      process.env.KALSHI_API_KEY_ID!,
      process.env.KALSHI_PRIVATE_KEY!,
      process.env.KALSHI_USE_DEMO === 'true'
    );

    console.log('[TradeExecutor] Finding matching Kalshi market...');
    const kalshiTicker = await findMatchingTicker(client, trade.market);

    if (!kalshiTicker) {
      throw new Error('No matching Kalshi market found for: ' + trade.market);
    }

    const numContracts = Math.ceil(decision.positionSize || 1);

    if (isSimulation) {
      console.log('[TradeExecutor] SIMULATION MODE: Skipping real Kalshi API calls');
      console.log('[TradeExecutor] Simulated order:', {
        ticker: kalshiTicker,
        contracts: numContracts,
        side: trade.side === 'YES' ? 'yes' : 'no',
      });

      await new Promise(resolve => setTimeout(resolve, 2000));

      return {
        id: tradeId,
        originalTrade: trade,
        decision,
        status: 'executed',
        executedAt: Date.now() / 1000,
        ourOrderId: 'sim-order-' + tradeId,
        kalshiTicker,
        kalshiResponse: {
          simulated: true,
          order: {
            order_id: 'sim-order-' + tradeId,
            ticker: kalshiTicker,
            side: trade.side === 'YES' ? 'yes' : 'no',
            action: 'buy',
            count: numContracts,
            status: 'filled',
          }
        },
        isSimulation: true,
      };
    }

    console.log('[TradeExecutor] LIVE MODE: Checking Kalshi balance...');
    const balanceData = await client.getBalance();
    console.log('[TradeExecutor] Current balance:', balanceData.balance);

    const estimatedCost = numContracts * 99;

    if (balanceData.balance < estimatedCost) {
      throw new Error('Insufficient balance: have $' + (balanceData.balance / 100) + ', need ~$' + (estimatedCost / 100));
    }

    console.log('[TradeExecutor] Placing order on Kalshi:', {
      ticker: kalshiTicker,
      contracts: numContracts,
      side: trade.side === 'YES' ? 'yes' : 'no',
    });

    const orderResponse = await client.createOrder(
      kalshiTicker,
      'buy',
      numContracts,
      trade.side === 'YES' ? 'yes' : 'no'
    );

    console.log('[TradeExecutor] Kalshi order executed:', orderResponse);

    return {
      id: tradeId,
      originalTrade: trade,
      decision,
      status: 'executed',
      executedAt: Date.now() / 1000,
      ourOrderId: orderResponse.order?.order_id || 'unknown',
      kalshiTicker,
      kalshiResponse: orderResponse,
      isSimulation: false,
    };
  } catch (error) {
    console.error('[TradeExecutor] Trade execution failed:', error);

    return {
      id: tradeId,
      originalTrade: trade,
      decision,
      status: 'failed',
      error: error instanceof Error ? error.message : 'Unknown error',
      isSimulation,
    };
  }
}


===== C:\Users\burba\tailsharp\src\lib\trading\transactionParser.ts =====

export interface ParsedTrade {
  market: string;
  side: 'YES' | 'NO';
  amount: number;
  price: number;
  walletAddress: string;
  signature: string;
  timestamp: number;
}

export function parseTransaction(tx: any): ParsedTrade | null {
  try {
    const description = tx.description || '';
    
    if (!description && !tx.tokenTransfers?.length) {
      return null;
    }

    let marketName = 'unknown-market';
    if (description) {
      marketName = description;
    }

    // Determine side from description or default
    let side: 'YES' | 'NO' = 'YES';
    const lowerDesc = description.toLowerCase();
    if (lowerDesc.includes(' no ') || lowerDesc.startsWith('no ') || lowerDesc.endsWith(' no')) {
      side = 'NO';
    }
    
    // Check for explicit side in source field
    if (tx.side === 'NO' || tx.side === 'no') {
      side = 'NO';
    } else if (tx.side === 'YES' || tx.side === 'yes') {
      side = 'YES';
    }

    const amount = tx.tokenTransfers?.[0]?.tokenAmount || tx.amount || 100;

    return {
      market: marketName,
      side: side,
      amount: amount,
      price: 0.65,
      walletAddress: tx.feePayer,
      signature: tx.signature,
      timestamp: tx.timestamp || Date.now() / 1000,
    };
  } catch (error) {
    console.error('Failed to parse transaction:', error);
    return null;
  }
}

export function isPredictionMarketTrade(tx: any): boolean {
  const description = tx.description?.toLowerCase() || '';
  const source = tx.source?.toLowerCase() || '';
  
  // Check source for known prediction market platforms
  const predictionSources = ['polymarket', 'kalshi', 'predictit', 'manifold', 'metaculus'];
  if (predictionSources.some(s => source.includes(s))) {
    return true;
  }
  
  // Check description for prediction market keywords
  const predictionKeywords = [
    'swap', 'trade', 'prediction', 'market', 'bet', 'wager',
    'will ', 'won\'t ', 'trump', 'biden', 'election', 'president',
    'yes', 'no', 'outcome', 'contract'
  ];
  
  if (predictionKeywords.some(keyword => description.includes(keyword))) {
    return true;
  }
  
  // Check for token transfers (common in prediction market trades)
  if (tx.tokenTransfers?.length > 0) {
    return true;
  }
  
  return false;
}


===== C:\Users\burba\tailsharp\src\lib\env.ts =====

// Client-side check (works in browser and server)
export const IS_SIMULATION =
  process.env.NEXT_PUBLIC_TAILSHARP_SIMULATION === 'true';

// For server-side only code, we can also check the non-public version as fallback
export const IS_SIMULATION_SERVER =
  process.env.NEXT_PUBLIC_TAILSHARP_SIMULATION === 'true' ||
  process.env.TAILSHARP_SIMULATION === 'true';


===== C:\Users\burba\tailsharp\src\types\index.ts =====

// src/types/index.ts

export interface Trader {
  address: string;
  displayName: string | null;
  avatar: string | null;
  stats: TraderStats;
  positions: Position[];
  followers: number;
  isVerified: boolean;
}

export interface TraderStats {
  totalTrades: number;
  winRate: number;
  roi: number;
  sharpeRatio: number;
  avgPositionSize: number;
  totalVolume: number;
  lastActiveAt: Date;
}

export interface Position {
  id: string;
  marketId: string;
  marketTitle: string;
  outcome: 'YES' | 'NO';
  contracts: number;
  avgPrice: number;
  currentPrice: number;
  pnl: number;
  pnlPercent: number;
  openedAt: Date;
}

export interface Market {
  id: string;
  title: string;
  description: string;
  category: string;
  yesPrice: number;
  noPrice: number;
  volume24h: number;
  expiresAt: Date;
  status: 'open' | 'closed' | 'settled';
}

export interface CopySettings {
  traderId: string;
  allocationUsd: number;
  maxPositionPercent: number;
  stopLossPercent: number;
  copyOpenPositions: boolean;
  isActive: boolean;
}

export interface User {
  walletAddress: string;
  following: CopySettings[];
  createdAt: Date;
}
